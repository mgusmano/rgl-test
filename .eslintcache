[{"c:\\work\\React\\rgl-test\\src\\index.js":"1","c:\\work\\React\\rgl-test\\src\\App.js":"2","C:\\work\\React\\rgl-test\\src\\index.js":"3","C:\\work\\React\\rgl-test\\src\\App.js":"4","C:\\work\\React\\rgl-test\\src\\ChildWindow.js":"5","C:\\work\\React\\rgl-test\\src\\DynamicLayout.jsx":"6","C:\\work\\React\\rgl-test\\src\\ContainerWindow.js":"7","C:\\work\\React\\rgl-test\\src\\globalstate\\GlobalStateProvider.js":"8","C:\\work\\React\\rgl-test\\src\\globalstate\\GlobalStateReducer.js":"9","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\index.js":"10","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\build\\responsiveUtils.js":"11","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\build\\ReactGridLayout.js":"12","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\build\\ResponsiveReactGridLayout.js":"13","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\build\\utils.js":"14","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\build\\components\\WidthProvider.js":"15","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\build\\calculateUtils.js":"16","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\build\\GridItem.js":"17","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\build\\ReactGridLayoutPropTypes.js":"18","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\build\\fastRGLPropsEqual.js":"19","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\lib\\responsiveUtils.js":"20","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\lib\\utils.js":"21","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\lib\\ReactGridLayout.jsx":"22","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\lib\\ResponsiveReactGridLayout.jsx":"23","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\lib\\components\\WidthProvider.jsx":"24","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\lib\\fastRGLPropsEqual.js":"25","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\lib\\ReactGridLayoutPropTypes.js":"26","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\lib\\calculateUtils.js":"27","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\lib\\GridItem.jsx":"28"},{"size":197,"mtime":499162500000,"results":"29","hashOfConfig":"30"},{"size":368,"mtime":499162500000,"results":"31","hashOfConfig":"30"},{"size":1825,"mtime":1607025073607,"results":"32","hashOfConfig":"33"},{"size":4601,"mtime":1607025587680,"results":"34","hashOfConfig":"33"},{"size":440,"mtime":1607021387998,"results":"35","hashOfConfig":"33"},{"size":2236,"mtime":1607025458550,"results":"36","hashOfConfig":"33"},{"size":612,"mtime":1607025413505,"results":"37","hashOfConfig":"33"},{"size":696,"mtime":1607023531123,"results":"38","hashOfConfig":"33"},{"size":12648,"mtime":1607022748007,"results":"39","hashOfConfig":"33"},{"size":336,"mtime":1607023737929,"results":"40","hashOfConfig":"33"},{"size":3677,"mtime":1607002236910,"results":"41","hashOfConfig":"33"},{"size":30197,"mtime":1607012717366,"results":"42","hashOfConfig":"33"},{"size":17840,"mtime":1607002236894,"results":"43","hashOfConfig":"33"},{"size":22724,"mtime":1607002236991,"results":"44","hashOfConfig":"33"},{"size":8983,"mtime":1607023672522,"results":"45","hashOfConfig":"33"},{"size":6169,"mtime":1607002236228,"results":"46","hashOfConfig":"33"},{"size":25547,"mtime":1607012171865,"results":"47","hashOfConfig":"33"},{"size":6879,"mtime":1607002236830,"results":"48","hashOfConfig":"33"},{"size":1345,"mtime":1607002236475,"results":"49","hashOfConfig":"33"},{"size":3691,"mtime":1606910183566,"results":"50","hashOfConfig":"33"},{"size":21574,"mtime":1606996872305,"results":"51","hashOfConfig":"33"},{"size":20488,"mtime":1607023765861,"results":"52","hashOfConfig":"33"},{"size":9918,"mtime":1607025495467,"results":"53","hashOfConfig":"33"},{"size":2660,"mtime":1607012445131,"results":"54","hashOfConfig":"33"},{"size":1385,"mtime":1606910183554,"results":"55","hashOfConfig":"33"},{"size":6575,"mtime":1606910183591,"results":"56","hashOfConfig":"33"},{"size":5396,"mtime":1606910183578,"results":"57","hashOfConfig":"33"},{"size":19207,"mtime":1607006810886,"results":"58","hashOfConfig":"33"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"s8827c",{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1skdj1s",{"filePath":"65","messages":"66","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"69"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"74","messages":"75","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"69"},{"filePath":"76","messages":"77","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"78","usedDeprecatedRules":"69"},{"filePath":"79","messages":"80","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"69"},{"filePath":"81","messages":"82","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":null},{"filePath":"83","messages":"84","errorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":1,"source":null},{"filePath":"85","messages":"86","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":1,"source":null},{"filePath":"87","messages":"88","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":1,"source":null},{"filePath":"89","messages":"90","errorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":1,"source":null},{"filePath":"91","messages":"92","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":1,"source":null},{"filePath":"93","messages":"94","errorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":1,"source":null},{"filePath":"95","messages":"96","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":null},{"filePath":"97","messages":"98","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"99","messages":"100","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"69"},{"filePath":"101","messages":"102","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"69"},{"filePath":"103","messages":"104","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"105","usedDeprecatedRules":"69"},{"filePath":"106","messages":"107","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"108","usedDeprecatedRules":"69"},{"filePath":"109","messages":"110","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"69"},{"filePath":"111","messages":"112","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"113","usedDeprecatedRules":"69"},{"filePath":"114","messages":"115","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"116","usedDeprecatedRules":"69"},{"filePath":"117","messages":"118","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"119","usedDeprecatedRules":"69"},{"filePath":"120","messages":"121","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"122","usedDeprecatedRules":"69"},"c:\\work\\React\\rgl-test\\src\\index.js",[],"c:\\work\\React\\rgl-test\\src\\App.js",[],"C:\\work\\React\\rgl-test\\src\\index.js",[],"C:\\work\\React\\rgl-test\\src\\App.js",["123","124","125","126","127","128","129"],"C:\\work\\React\\rgl-test\\src\\ChildWindow.js",[],["130","131"],"C:\\work\\React\\rgl-test\\src\\DynamicLayout.jsx",[],"C:\\work\\React\\rgl-test\\src\\ContainerWindow.js",[],"C:\\work\\React\\rgl-test\\src\\globalstate\\GlobalStateProvider.js",[],"C:\\work\\React\\rgl-test\\src\\globalstate\\GlobalStateReducer.js",["132","133"],"import produce from 'immer'\r\n\r\nexport const GlobalStateReducer = (state, action) => {\r\n  const { payload } = action;\r\n  switch (action.type) {\r\n\r\n    case 'widgets':\r\n      //console.log(\"dashboardData\",payload)\r\n      return produce(state,(draft) => {\r\n        draft.widgets = payload\r\n      })\r\n\r\n    case 'numberofwidgets':\r\n      //console.log(\"dashboardData\",payload)\r\n      return produce(state,(draft) => {\r\n        draft.numberofwidgets = payload\r\n      })\r\n\r\n\r\n\r\n\r\n\r\n\r\n    case 'dashboardData':\r\n      //console.log(\"dashboardData\",payload)\r\n      return produce(state,(draft) => {\r\n        draft.dashboardData = payload\r\n        draft.highWidgetId = payload.dashboard.widgets.length\r\n      })\r\n\r\n      //return { ...state, dashboardData: payload, highWidgetId: payload.dashboard.widgets.length }\r\n    // case 'widgetData':\r\n    //   return { ...state, widgetData: payload, highWidgetId: payload.length }\r\n    case 'appTitle':\r\n      return produce(state,(draft) => {\r\n        draft.dashboardData.appTitle = payload\r\n      })\r\n    case 'userName':\r\n      return produce(state,(draft) => {\r\n        draft.userName = payload\r\n      })\r\n\r\n      case 'selectedIndex':\r\n        return produce(state,(draft) => {\r\n          draft.selectedIndex = payload\r\n        })\r\n\r\n        case \"REPLACE_WIDGET\":\r\n          console.log(\"REPLACE_WIDGET\",payload)\r\n          return produce(state, draft => {\r\n            var index = draft.dashboardData.dashboard.widgets.map(item => item.id).indexOf(payload.id);\r\n            if (index !== -1) {\r\n              draft.dashboardData.dashboard.widgets[index] =  payload\r\n            }\r\n          })\r\n\r\n          case \"ADD_WIDGET\" :\r\n            return {\r\n                ...state,\r\n                widgets: [\r\n                  ...state.widgets,\r\n                  {\r\n                    id: 10,\r\n                    properties: {\r\n                      mode: payload.mode,\r\n                      position: {x: payload.x,y: payload.y},\r\n                      size: {width: payload.w,height: payload.h}\r\n                    },\r\n                  }\r\n                ]\r\n            }\r\n\r\n\r\n\r\n          case \"ADD_WIDGET4\":\r\n            //console.log(\"ADD_WIDGET\",payload)\r\n            return produce(state, draft => {\r\n              draft.widgets.push({\r\n                id: draft.highWidgetId,\r\n                properties: {\r\n                  mode: payload.mode,\r\n                  position: {x: payload.x,y: payload.y},\r\n                  size: {width: payload.w,height: payload.h}\r\n                },\r\n              })\r\n            })\r\n\r\n\r\n      case \"ADD_WIDGET3\":\r\n        //console.log(\"ADD_WIDGET\",payload)\r\n        return produce(state, draft => {\r\n          draft.highWidgetId = draft.highWidgetId + 1\r\n          draft.numberofwidgets = draft.numberofwidgets + 1\r\n          draft.widgets.push({\r\n            id: draft.highWidgetId,\r\n            events: {},\r\n            WidgetForm: null,\r\n            defaultTitle: payload.title,\r\n            type: payload.type,\r\n            properties: {\r\n              mode: payload.mode,\r\n              position: {x: payload.x,y: payload.y},\r\n              size: {width: payload.w,height: payload.h}\r\n            },\r\n          })\r\n        })\r\n\r\n        case \"ADD_WIDGET2\":\r\n          //console.log(\"ADD_WIDGET\",payload)\r\n          return produce(state, draft => {\r\n            draft.highWidgetId = draft.highWidgetId + 1\r\n            draft.dashboardData.dashboard.widgets.push({\r\n              id: draft.highWidgetId,\r\n              events: {},\r\n              WidgetForm: null,\r\n              defaultTitle: payload.title,\r\n              type: payload.type,\r\n              properties: {\r\n                mode: payload.mode,\r\n                position: {x: payload.x,y: payload.y},\r\n                size: {width: payload.w,height: payload.h}\r\n              },\r\n            })\r\n          })\r\n\r\n    // case \"INITIALIZE_WIDGET\":\r\n    //   console.log(\"INITIALIZE_WIDGET\",payload.id)\r\n    //   return produce(state, draft => {\r\n    //     console.log(draft)\r\n    //     var index = draft.dashboardData.dashboard.widgets.map(item => item.id).indexOf(payload.id);\r\n    //     if (index !== -1) {\r\n    //       draft.dashboardData.dashboard.widgets[index].events = {}\r\n    //     }\r\n    //   })\r\n\r\n    case \"SET_EVENT_FIRSTONE\":\r\n      console.log(\"SET_EVENT_FIRSTONE\",payload.id)\r\n      return produce(state, draft => {\r\n        var index = draft.dashboardData.dashboard.widgets.map(item => item.id).indexOf(payload.id);\r\n        if (index !== -1) {\r\n          draft.dashboardData.dashboard.widgets[index].events.FirstOne = payload.receiver\r\n          //draft.dashboardData.dashboard.widgets[index].FirstOne = payload.receiver\r\n        }\r\n      })\r\n\r\n      case \"SET_WIDGET_FORM\":\r\n        console.log(\"SET_WIDGET_FORM\",payload.id)\r\n        return produce(state, draft => {\r\n          console.log(draft)\r\n          var index = draft.dashboardData.dashboard.widgets.map(item => item.id).indexOf(payload.id);\r\n          if (index !== -1) {\r\n            //console.log(draft.dashboardData.dashboard.widgets)\r\n            draft.dashboardData.dashboard.widgets[index].WidgetForm = payload.WidgetForm\r\n            //draft.dashboardData.dashboard.widgets[index].FirstOne = payload.receiver\r\n          }\r\n        })\r\n\r\n        case \"CLEAR_WIDGETS\":\r\n          return produce(state, draft => {\r\n            draft.widgets = []\r\n          })\r\n\r\n\r\n\r\n\r\n\r\n\r\n      case \"TILE_WIDGETS\":\r\n        return produce(state, draft => {\r\n          var columns = 3\r\n          var a = document.getElementById('absolute')\r\n          var length = draft.dashboardData.dashboard.widgets.length\r\n          var rows = length / columns\r\n          rows = Math.ceil(rows)\r\n          if (length % columns > 1) {\r\n            rows = rows + 1\r\n          }\r\n\r\n          var space = 20\r\n          //debugger\r\n          //var w = a.scrollWidth\r\n          //var h = a.scrollHeight - 40\r\n          var w = a.clientWidth - space\r\n          var h = a.clientHeight - space\r\n          //var l = draft.dashboardData.dashboard.widgets.length\r\n\r\n\r\n          //var newWidth = w/l\r\n          var newWidth = w/columns\r\n\r\n          //console.log(h)\r\n          //console.log(rows)\r\n\r\n          var newHeight = h/rows\r\n\r\n          //console.log(newHeight)\r\n          //console.dir(a)\r\n          //console.log(w)\r\n          //console.log(l)\r\n          //console.log(newWidth)\r\n\r\n          var left = 0\r\n          var width = newWidth - space\r\n\r\n          var currentCol = 1\r\n          var currentRow = 1\r\n          var newY = 0\r\n          draft.dashboardData.dashboard.widgets.forEach(widget => {\r\n            var index = draft.dashboardData.dashboard.widgets.map(item => item.id).indexOf(widget.id);\r\n            if (index !== -1) {\r\n\r\n              if (currentCol > columns) {\r\n                left = 0\r\n                currentRow = currentRow + 1\r\n                newY = newY + newHeight\r\n                currentCol = 1\r\n              }\r\n              // else {\r\n              //   currentCol = currentCol + 1\r\n              // }\r\n              //console.log(currentRow,currentCol)\r\n\r\n              draft.dashboardData.dashboard.widgets[index].properties.position =  {x:left,y: newY}\r\n              draft.dashboardData.dashboard.widgets[index].properties.size = {width: width,height: newHeight - space}\r\n              left = width + left + space\r\n\r\n              currentCol = currentCol + 1\r\n\r\n            }\r\n          })\r\n\r\n        })\r\n\r\n\r\n      case \"TILE_WIDGETS2\":\r\n        return produce(state, draft => {\r\n          var a = document.getElementById('absolute')\r\n          var length = draft.dashboardData.dashboard.widgets.length\r\n          var space = 15\r\n          //debugger\r\n          //var w = a.scrollWidth\r\n          //var h = a.scrollHeight - 40\r\n          var w = a.clientWidth - space\r\n          var h = a.clientHeight - space\r\n          var l = draft.dashboardData.dashboard.widgets.length\r\n          var newWidth = w/l\r\n          //console.dir(a)\r\n          //console.log(w)\r\n          //console.log(l)\r\n          //console.log(newWidth)\r\n\r\n\r\n          // var left = 20\r\n          // var width = newWidth - 40\r\n\r\n          // draft.dashboardData.dashboard.widgets.forEach(widget => {\r\n          //   var index = draft.dashboardData.dashboard.widgets.map(item => item.id).indexOf(widget.id);\r\n          //   if (index !== -1) {\r\n          //     draft.dashboardData.dashboard.widgets[index].properties.position =  {x:left,y: 20}\r\n          //     draft.dashboardData.dashboard.widgets[index].properties.size = {width: width,height: h}\r\n          //     left = width + left + 30\r\n          //   }\r\n          // })\r\n\r\n\r\n\r\n          var left = 0\r\n          var width = newWidth - space\r\n\r\n          draft.dashboardData.dashboard.widgets.forEach(widget => {\r\n            var index = draft.dashboardData.dashboard.widgets.map(item => item.id).indexOf(widget.id);\r\n            if (index !== -1) {\r\n              draft.dashboardData.dashboard.widgets[index].properties.position =  {x:left,y: 0}\r\n              draft.dashboardData.dashboard.widgets[index].properties.size = {width: width,height: h}\r\n              left = width + left + space\r\n            }\r\n          })\r\n\r\n        })\r\n    case \"CHANGE_WIDGET_MODE\":\r\n      return produce(state, draft => {\r\n        var index = draft.dashboardData.dashboard.widgets.map(item => item.id).indexOf(payload.id);\r\n        if (index !== -1) {\r\n          if (draft.dashboardData.dashboard.widgets[index].properties.mode == 'chart') {\r\n            draft.dashboardData.dashboard.widgets[index].properties.mode = 'grid'\r\n          }\r\n          else {\r\n            draft.dashboardData.dashboard.widgets[index].properties.mode = 'chart'\r\n          }\r\n        }\r\n      })\r\n      case \"DELETE_WIDGET\":\r\n        //console.log('DELETE_WIDGET')\r\n        return produce(state, draft => {\r\n          var index = draft.dashboardData.dashboard.widgets.map(item => item.id).indexOf(payload.id);\r\n          if (index !== -1) {\r\n            draft.dashboardData.dashboard.widgets.splice(index, 1);\r\n          }\r\n        })\r\n    case \"UPDATE_WIDGET\":\r\n      return produce(state, draft => {\r\n        var index = draft.dashboardData.dashboard.widgets.map(item => item.id).indexOf(payload.id);\r\n        if (index !== -1) {\r\n          draft.dashboardData.dashboard.widgets[index].properties.position =  {x: payload.x,y: payload.y}\r\n          draft.dashboardData.dashboard.widgets[index].properties.size = {width: payload.w,height: payload.h}\r\n        }\r\n      })\r\n    case \"MOVE_WIDGET\":\r\n      return produce(state, draft => {\r\n        var index = draft.dashboardData.dashboard.widgets.map(item => item.id).indexOf(payload.id);\r\n        if (index !== -1) {\r\n          draft.dashboardData.dashboard.widgets[index].properties.position = {x: payload.x,y: payload.y}\r\n        }\r\n      })\r\n\r\n      // case \"RESIZE_WIDGET\":\r\n      //   console.log(\"RESIZE_WIDGET\",payload.id)\r\n      //   return produce(state, draft => {\r\n      //     draft.dashboardData.dashboard.widgets[0].test = true\r\n      //   })\r\n\r\n      case \"SET_MESSAGE\":\r\n        console.log(\"SET_MESSAGE\",payload.id)\r\n        return produce(state, draft => {\r\n          //console.log(draft)\r\n          var index = draft.dashboardData.dashboard.widgets.map(item => item.id).indexOf(payload.id);\r\n          if (index !== -1) {\r\n            draft.dashboardData.dashboard.widgets[index].message = payload.message\r\n          }\r\n        })\r\n\r\n\r\n\r\n\r\n    case \"RESIZE_WIDGET\":\r\n      console.log(\"RESIZE_WIDGET\",payload.id)\r\n      return produce(state, draft => {\r\n        //console.log(draft)\r\n        var index = draft.dashboardData.dashboard.widgets.map(item => item.id).indexOf(payload.id);\r\n        if (index !== -1) {\r\n          draft.dashboardData.dashboard.widgets[index].properties.position = {x: payload.x, y: payload.y}\r\n          draft.dashboardData.dashboard.widgets[index].properties.size = {width: payload.w,height: payload.h}\r\n        }\r\n      })\r\n    case \"ACTIVATE_WIDGET\":\r\n      console.log(\"ACTIVATE_WIDGET\",payload.id)\r\n      return produce(state, draft => {\r\n        draft.dashboardData.dashboard.widgets.forEach(widget => widget.active = false)\r\n        var index = draft.dashboardData.dashboard.widgets.map(item => item.id).indexOf(payload.id);\r\n        if (index !== -1) {\r\n          draft.activeItemId = payload.id\r\n          draft.activeWidgetForm = draft.dashboardData.dashboard.widgets[index].WidgetForm\r\n          draft.dashboardData.dashboard.widgets[index].active = true\r\n          draft.toolkitTitle = draft.dashboardData.dashboard.widgets[index].defaultTitle\r\n        }\r\n      })\r\n    default:\r\n      return state;\r\n  }\r\n}","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\index.js",[],"C:\\work\\React\\rgl-test\\src\\react-grid-layout\\build\\responsiveUtils.js",["134"],"C:\\work\\React\\rgl-test\\src\\react-grid-layout\\build\\ReactGridLayout.js",["135","136","137","138","139","140","141","142","143","144","145"],"C:\\work\\React\\rgl-test\\src\\react-grid-layout\\build\\ResponsiveReactGridLayout.js",["146","147","148","149","150","151","152","153","154","155","156","157"],"C:\\work\\React\\rgl-test\\src\\react-grid-layout\\build\\utils.js",["158","159","160","161","162","163","164","165"],"C:\\work\\React\\rgl-test\\src\\react-grid-layout\\build\\components\\WidthProvider.js",["166","167","168","169","170","171","172","173","174","175"],"C:\\work\\React\\rgl-test\\src\\react-grid-layout\\build\\calculateUtils.js",["176","177","178"],"C:\\work\\React\\rgl-test\\src\\react-grid-layout\\build\\GridItem.js",["179","180","181","182","183","184","185","186","187","188"],"C:\\work\\React\\rgl-test\\src\\react-grid-layout\\build\\ReactGridLayoutPropTypes.js",["189","190"],"C:\\work\\React\\rgl-test\\src\\react-grid-layout\\build\\fastRGLPropsEqual.js",[],"C:\\work\\React\\rgl-test\\src\\react-grid-layout\\lib\\responsiveUtils.js",[],"C:\\work\\React\\rgl-test\\src\\react-grid-layout\\lib\\utils.js",[],"C:\\work\\React\\rgl-test\\src\\react-grid-layout\\lib\\ReactGridLayout.jsx",["191","192","193"],"// @flow\nimport React from \"react\";\n\nimport isEqual from \"lodash.isequal\";\nimport classNames from \"classnames\";\nimport {\n  autoBindHandlers,\n  bottom,\n  childrenEqual,\n  cloneLayoutItem,\n  compact,\n  getLayoutItem,\n  moveElement,\n  synchronizeLayoutWithChildren,\n  getAllCollisions,\n  compactType,\n  noop,\n  fastRGLPropsEqual\n} from \"./utils\";\n\nimport { calcXY } from \"./calculateUtils\";\n\nimport GridItem from \"./GridItem\";\nimport ReactGridLayoutPropTypes from \"./ReactGridLayoutPropTypes\";\nimport type {\n  ChildrenArray as ReactChildrenArray,\n  Element as ReactElement\n} from \"react\";\n\n// Types\nimport type {\n  CompactType,\n  GridResizeEvent,\n  GridDragEvent,\n  DragOverEvent,\n  Layout,\n  DroppingPosition,\n  LayoutItem\n} from \"./utils\";\n\nimport type { PositionParams } from \"./calculateUtils\";\n\nimport type { Props } from \"./ReactGridLayoutPropTypes\";\n\ntype State = {\n  activeDrag: ?LayoutItem,\n  layout: Layout,\n  mounted: boolean,\n  oldDragItem: ?LayoutItem,\n  oldLayout: ?Layout,\n  oldResizeItem: ?LayoutItem,\n  droppingDOMNode: ?ReactElement<any>,\n  droppingPosition?: DroppingPosition,\n  // Mirrored props\n  children: ReactChildrenArray<ReactElement<any>>,\n  compactType?: CompactType,\n  propsLayout?: Layout\n};\n\n\n\n// End Types\n\nconst layoutClassName = \"react-grid-layout\";\nlet isFirefox = false;\n// Try...catch will protect from navigator not existing (e.g. node) or a bad implementation of navigator\ntry {\n  isFirefox = /firefox/i.test(navigator.userAgent);\n} catch (e) {\n  /* Ignore */\n}\n\n/**\n * A reactive, fluid grid layout with draggable, resizable components.\n */\n\nexport default class ReactGridLayout extends React.Component<Props, State> {\n  // TODO publish internal ReactClass displayName transform\n  static displayName = \"ReactGridLayout\";\n\n\n  // Refactored to another module to make way for preval\n  static propTypes = ReactGridLayoutPropTypes;\n\n  static defaultProps = {\n    absoluteLayout:false,\n    autoSize: true,\n    cols: 12,\n    className: \"\",\n    style: {},\n    draggableHandle: \"\",\n    draggableCancel: \"\",\n    containerPadding: null,\n    rowHeight: 150,\n    maxRows: Infinity, // infinite vertical growth\n    layout: [],\n    margin: [10, 10],\n    isBounded: false,\n    isDraggable: true,\n    isResizable: true,\n    isDroppable: false,\n    useCSSTransforms: true,\n    transformScale: 1,\n    verticalCompact: true,\n    compactType: \"vertical\",\n    preventCollision: false,\n    droppingItem: {\n      i: \"__dropping-elem__\",\n      h: 1,\n      w: 1\n    },\n    resizeHandles: [\"se\"],\n    onLayoutChange: noop,\n    onDragStart: noop,\n    onDrag: noop,\n    onDragStop: noop,\n    onResizeStart: noop,\n    onResize: noop,\n    onResizeStop: noop,\n    onDrop: noop\n  };\n\n  state: State = {\n    activeDrag: null,\n    layout: synchronizeLayoutWithChildren(\n      this.props.layout,\n      this.props.children,\n      this.props.cols,\n      // Legacy support for verticalCompact: false\n      compactType(this.props)\n    ),\n    mounted: false,\n    oldDragItem: null,\n    oldLayout: null,\n    oldResizeItem: null,\n    droppingDOMNode: null,\n    children: []\n  };\n\n  dragEnterCounter = 0;\n\n  constructor(props: Props, context: any): void {\n    super(props, context);\n    console.log('mjg6')\n    //console.log(this.props.layout)\n    autoBindHandlers(this, [\n      \"onDragStart\",\n      \"onDrag\",\n      \"onDragStop\",\n      \"onResizeStart\",\n      \"onResize\",\n      \"onResizeStop\"\n    ]);\n  }\n\n  componentDidMount() {\n    this.setState({ mounted: true });\n    // Possibly call back with layout on mount. This should be done after correcting the layout width\n    // to ensure we don't rerender with the wrong width.\n    this.onLayoutMaybeChanged(this.state.layout, this.props.layout);\n  }\n\n  static getDerivedStateFromProps(nextProps: Props, prevState: State) {\n    let newLayoutBase;\n\n    if (prevState.activeDrag) {\n      return null;\n    }\n\n    // Legacy support for compactType\n    // Allow parent to set layout directly.\n    if (\n      !isEqual(nextProps.layout, prevState.propsLayout) ||\n      nextProps.compactType !== prevState.compactType\n    ) {\n      newLayoutBase = nextProps.layout;\n    } else if (!childrenEqual(nextProps.children, prevState.children)) {\n      // If children change, also regenerate the layout. Use our state\n      // as the base in case because it may be more up to date than\n      // what is in props.\n      newLayoutBase = prevState.layout;\n    }\n\n    // We need to regenerate the layout.\n    if (newLayoutBase) {\n      const newLayout = synchronizeLayoutWithChildren(\n        newLayoutBase,\n        nextProps.children,\n        nextProps.cols,\n        compactType(nextProps)\n      );\n\n      return {\n        layout: newLayout,\n        // We need to save these props to state for using\n        // getDerivedStateFromProps instead of componentDidMount (in which we would get extra rerender)\n        compactType: nextProps.compactType,\n        children: nextProps.children,\n        propsLayout: nextProps.layout\n      };\n    }\n\n    return null;\n  }\n\n  shouldComponentUpdate(nextProps: Props, nextState: State) {\n    return (\n      // NOTE: this is almost always unequal. Therefore the only way to get better performance\n      // from SCU is if the user intentionally memoizes children. If they do, and they can\n      // handle changes properly, performance will increase.\n      this.props.children !== nextProps.children ||\n      !fastRGLPropsEqual(this.props, nextProps, isEqual) ||\n      this.state.activeDrag !== nextState.activeDrag ||\n      this.state.mounted !== nextState.mounted ||\n      this.state.droppingPosition !== nextState.droppingPosition\n    );\n  }\n\n  componentDidUpdate(prevProps: Props, prevState: State) {\n    if (!this.state.activeDrag) {\n      const newLayout = this.state.layout;\n      const oldLayout = prevState.layout;\n\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    }\n  }\n\n  /**\n   * Calculates a pixel value for the container.\n   * @return {String} Container height in pixels.\n   */\n  containerHeight() {\n    if (!this.props.autoSize) return;\n    const nbRow = bottom(this.state.layout);\n    const containerPaddingY = this.props.containerPadding\n      ? this.props.containerPadding[1]\n      : this.props.margin[1];\n    return (\n      nbRow * this.props.rowHeight +\n      (nbRow - 1) * this.props.margin[1] +\n      containerPaddingY * 2 +\n      \"px\"\n    );\n  }\n\n  /**\n   * When dragging starts\n   * @param {String} i Id of the child\n   * @param {Number} x X position of the move\n   * @param {Number} y Y position of the move\n   * @param {Event} e The mousedown event\n   * @param {Element} node The current dragging DOM element\n   */\n  onDragStart(i: string, x: number, y: number, { e, node }: GridDragEvent) {\n    const { layout } = this.state;\n    var l = getLayoutItem(layout, i);\n    if (!l) return;\n\n    this.setState({\n      oldDragItem: cloneLayoutItem(l),\n      oldLayout: this.state.layout\n    });\n\n    return this.props.onDragStart(layout, l, l, null, e, node);\n  }\n\n  /**\n   * Each drag movement create a new dragelement and move the element to the dragged location\n   * @param {String} i Id of the child\n   * @param {Number} x X position of the move\n   * @param {Number} y Y position of the move\n   * @param {Event} e The mousedown event\n   * @param {Element} node The current dragging DOM element\n   */\n  onDrag(i: string, x: number, y: number, { e, node }: GridDragEvent) {\n    const { oldDragItem } = this.state;\n    let { layout } = this.state;\n    const { cols } = this.props;\n    var l = getLayoutItem(layout, i);\n    if (!l) return;\n\n    // // Create placeholder (display only)\n    // var placeholder = {\n    //   w: l.w,\n    //   h: l.h,\n    //   x: l.x,\n    //   y: l.y,\n    //   placeholder: true,\n    //   i: i\n    // };\n\n\n\n    console.log('in onDrag',l.absoluteLayout)\n\n    // Create placeholder (display only)\n    var placeholder = {\n      w: l.w,\n      h: l.h,\n      x: l.x,\n      y: l.y,\n      placeholder: !l.absoluteLayout,\n      i: i\n    };\n\n    // Move the element to the dragged location.\n    const isUserAction = true;\n    layout = moveElement(\n      layout,\n      l,\n      x,\n      y,\n      isUserAction,\n      this.props.preventCollision,\n      compactType(this.props),\n      cols\n    );\n\n    this.props.onDrag(layout, oldDragItem, l, placeholder, e, node);\n\n    this.setState({\n      layout: compact(layout, compactType(this.props), cols),\n      activeDrag: placeholder\n    });\n  }\n\n  /**\n   * When dragging stops, figure out which position the element is closest to and update its x and y.\n   * @param  {String} i Index of the child.\n   * @param {Number} x X position of the move\n   * @param {Number} y Y position of the move\n   * @param {Event} e The mousedown event\n   * @param {Element} node The current dragging DOM element\n   */\n  onDragStop(i: string, x: number, y: number, { e, node }: GridDragEvent) {\n    if (!this.state.activeDrag) return;\n\n    const { oldDragItem } = this.state;\n    let { layout } = this.state;\n    const { cols, preventCollision } = this.props;\n    const l = getLayoutItem(layout, i);\n    if (!l) return;\n\n    //console.log('move')\n    //console.log(preventCollision)\n    //console.log(this.props)\n    // Move the element here\n    const isUserAction = true;\n    layout = moveElement(\n      layout,\n      l,\n      x,\n      y,\n      isUserAction,\n      preventCollision,\n      compactType(this.props),\n      cols\n    );\n\n    this.props.onDragStop(layout, oldDragItem, l, null, e, node);\n\n    // Set state\n    const newLayout = compact(layout, compactType(this.props), cols);\n    const { oldLayout } = this.state;\n    this.setState({\n      activeDrag: null,\n      layout: newLayout,\n      oldDragItem: null,\n      oldLayout: null\n    });\n\n    this.onLayoutMaybeChanged(newLayout, oldLayout);\n  }\n\n  onLayoutMaybeChanged(newLayout: Layout, oldLayout: ?Layout) {\n    if (!oldLayout) oldLayout = this.state.layout;\n\n    if (!isEqual(oldLayout, newLayout)) {\n      this.props.onLayoutChange(newLayout);\n    }\n  }\n\n  onResizeStart(i: string, w: number, h: number, { e, node }: GridResizeEvent) {\n    const { layout } = this.state;\n    var l = getLayoutItem(layout, i);\n    if (!l) return;\n\n    this.setState({\n      oldResizeItem: cloneLayoutItem(l),\n      oldLayout: this.state.layout\n    });\n\n    this.props.onResizeStart(layout, l, l, null, e, node);\n  }\n\n  onResize(i: string, w: number, h: number, { e, node }: GridResizeEvent) {\n    const { layout, oldResizeItem } = this.state;\n    const { cols, preventCollision } = this.props;\n    const l: ?LayoutItem = getLayoutItem(layout, i);\n    if (!l) return;\n\n    // Something like quad tree should be used\n    // to find collisions faster\n    let hasCollisions;\n    if (preventCollision) {\n      const collisions = getAllCollisions(layout, { ...l, w, h }).filter(\n        layoutItem => layoutItem.i !== l.i\n      );\n      hasCollisions = collisions.length > 0;\n\n      // If we're colliding, we need adjust the placeholder.\n      if (hasCollisions) {\n        // adjust w && h to maximum allowed space\n        let leastX = Infinity,\n          leastY = Infinity;\n        collisions.forEach(layoutItem => {\n          if (layoutItem.x > l.x) leastX = Math.min(leastX, layoutItem.x);\n          if (layoutItem.y > l.y) leastY = Math.min(leastY, layoutItem.y);\n        });\n\n        if (Number.isFinite(leastX)) l.w = leastX - l.x;\n        if (Number.isFinite(leastY)) l.h = leastY - l.y;\n      }\n    }\n\n    if (!hasCollisions) {\n      // Set new width and height.\n      l.w = w;\n      l.h = h;\n    }\n\n    // Create placeholder element (display only)\n    var placeholder = {\n      w: l.w,\n      h: l.h,\n      x: l.x,\n      y: l.y,\n      static: true,\n      i: i\n    };\n\n    this.props.onResize(layout, oldResizeItem, l, placeholder, e, node);\n\n    // Re-compact the layout and set the drag placeholder.\n    this.setState({\n      layout: compact(layout, compactType(this.props), cols),\n      activeDrag: placeholder\n    });\n  }\n\n  onResizeStop(i: string, w: number, h: number, { e, node }: GridResizeEvent) {\n    const { layout, oldResizeItem } = this.state;\n    const { cols } = this.props;\n    var l = getLayoutItem(layout, i);\n\n    this.props.onResizeStop(layout, oldResizeItem, l, null, e, node);\n\n    // Set state\n    const newLayout = compact(layout, compactType(this.props), cols);\n    const { oldLayout } = this.state;\n    this.setState({\n      activeDrag: null,\n      layout: newLayout,\n      oldResizeItem: null,\n      oldLayout: null\n    });\n\n    this.onLayoutMaybeChanged(newLayout, oldLayout);\n  }\n\n  /**\n   * Create a placeholder object.\n   * @return {Element} Placeholder div.\n   */\n  placeholder(): ?ReactElement<any> {\n    const { activeDrag } = this.state;\n    console.log('activeDrag',activeDrag)\n    if (!activeDrag) return null;\n\n    if (activeDrag.placeholder == false) return null;\n\n    const {\n      width,\n      cols,\n      margin,\n      containerPadding,\n      rowHeight,\n      maxRows,\n      useCSSTransforms,\n      transformScale\n    } = this.props;\n\n    // {...this.state.activeDrag} is pretty slow, actually\n    return (\n      <GridItem\n        w={activeDrag.w}\n        h={activeDrag.h}\n        x={activeDrag.x}\n        y={activeDrag.y}\n        i={activeDrag.i}\n        className=\"react-grid-placeholder\"\n        containerWidth={width}\n        cols={cols}\n        margin={margin}\n        containerPadding={containerPadding || margin}\n        maxRows={maxRows}\n        rowHeight={rowHeight}\n        isDraggable={false}\n        isResizable={false}\n        isBounded={false}\n        useCSSTransforms={useCSSTransforms}\n        transformScale={transformScale}\n      >\n        <div />\n      </GridItem>\n    );\n  }\n\n  /**\n   * Given a grid item, set its style attributes & surround in a <Draggable>.\n   * @param  {Element} child React element.\n   * @return {Element}       Element wrapped in draggable and properly placed.\n   */\n  processGridItem(\n    child: ReactElement<any>,\n    isDroppingItem?: boolean\n  ): ?ReactElement<any> {\n    if (!child || !child.key) return;\n    const l = getLayoutItem(this.state.layout, String(child.key));\n    if (!l) return null;\n    console.log('l',l)\n    const {\n      width,\n      cols,\n      margin,\n      containerPadding,\n      rowHeight,\n      maxRows,\n      isDraggable,\n      isResizable,\n      isBounded,\n      useCSSTransforms,\n      transformScale,\n      draggableCancel,\n      draggableHandle,\n      resizeHandles,\n      resizeHandle\n    } = this.props;\n    const { mounted, droppingPosition } = this.state;\n\n    // Determine user manipulations possible.\n    // If an item is static, it can't be manipulated by default.\n    // Any properties defined directly on the grid item will take precedence.\n    const draggable =\n      typeof l.isDraggable === \"boolean\"\n        ? l.isDraggable\n        : !l.static && isDraggable;\n    const resizable =\n      typeof l.isResizable === \"boolean\"\n        ? l.isResizable\n        : !l.static && isResizable;\n    const resizeHandlesOptions = l.resizeHandles || resizeHandles;\n\n    // isBounded set on child if set on parent, and child is not explicitly false\n    const bounded = draggable && isBounded && l.isBounded !== false;\n\n    //console.log(l)\n//console.log(absoluteLayout)\n    return (\n      <GridItem\n        absoluteLayout={l.absoluteLayout}\n        containerWidth={width}\n        cols={cols}\n        margin={margin}\n        containerPadding={containerPadding || margin}\n        maxRows={maxRows}\n        rowHeight={rowHeight}\n        cancel={draggableCancel}\n        handle={draggableHandle}\n        onDragStop={this.onDragStop}\n        onDragStart={this.onDragStart}\n        onDrag={this.onDrag}\n        onResizeStart={this.onResizeStart}\n        onResize={this.onResize}\n        onResizeStop={this.onResizeStop}\n        isDraggable={draggable}\n        isResizable={resizable}\n        isBounded={bounded}\n        useCSSTransforms={useCSSTransforms && mounted}\n        usePercentages={!mounted}\n        transformScale={transformScale}\n        w={l.w}\n        h={l.h}\n        x={l.x}\n        y={l.y}\n        i={l.i}\n        minH={l.minH}\n        minW={l.minW}\n        maxH={l.maxH}\n        maxW={l.maxW}\n        static={l.static}\n        droppingPosition={isDroppingItem ? droppingPosition : undefined}\n        resizeHandles={resizeHandlesOptions}\n        resizeHandle={resizeHandle}\n      >\n        {child}\n      </GridItem>\n    );\n  }\n\n  // Called while dragging an element. Part of browser native drag/drop API.\n  // Native event target might be the layout itself, or an element within the layout.\n  onDragOver = (e: DragOverEvent) => {\n    // we should ignore events from layout's children in Firefox\n    // to avoid unpredictable jumping of a dropping placeholder\n    // FIXME remove this hack\n    if (\n      isFirefox &&\n      e.nativeEvent.target.className.indexOf(layoutClassName) === -1\n    ) {\n      // without this Firefox will not allow drop if currently over droppingItem\n      e.preventDefault();\n      return false;\n    }\n\n    const {\n      droppingItem,\n      margin,\n      cols,\n      rowHeight,\n      maxRows,\n      width,\n      containerPadding\n    } = this.props;\n    const { layout } = this.state;\n    // This is relative to the DOM element that this event fired for.\n    const { layerX, layerY } = e.nativeEvent;\n    const droppingPosition = { left: layerX, top: layerY, e };\n\n    if (!this.state.droppingDOMNode) {\n      const positionParams: PositionParams = {\n        cols,\n        margin,\n        maxRows,\n        rowHeight,\n        containerWidth: width,\n        containerPadding: containerPadding || margin\n      };\n\n      const calculatedPosition = calcXY(\n        positionParams,\n        layerY,\n        layerX,\n        droppingItem.w,\n        droppingItem.h\n      );\n\n      this.setState({\n        droppingDOMNode: <div key={droppingItem.i} />,\n        droppingPosition,\n        layout: [\n          ...layout,\n          {\n            ...droppingItem,\n            x: calculatedPosition.x,\n            y: calculatedPosition.y,\n            static: false,\n            isDraggable: true\n          }\n        ]\n      });\n    } else if (this.state.droppingPosition) {\n      const { left, top } = this.state.droppingPosition;\n      const shouldUpdatePosition = left != layerX || top != layerY;\n      if (shouldUpdatePosition) {\n        this.setState({ droppingPosition });\n      }\n    }\n\n    e.stopPropagation();\n    e.preventDefault();\n  };\n\n  removeDroppingPlaceholder = () => {\n    const { droppingItem, cols } = this.props;\n    const { layout } = this.state;\n\n    const newLayout = compact(\n      layout.filter(l => l.i !== droppingItem.i),\n      compactType(this.props),\n      cols\n    );\n\n    this.setState({\n      layout: newLayout,\n      droppingDOMNode: null,\n      activeDrag: null,\n      droppingPosition: undefined\n    });\n  };\n\n  onDragLeave = () => {\n    this.dragEnterCounter--;\n\n    // onDragLeave can be triggered on each layout's child.\n    // But we know that count of dragEnter and dragLeave events\n    // will be balanced after leaving the layout's container\n    // so we can increase and decrease count of dragEnter and\n    // when it'll be equal to 0 we'll remove the placeholder\n    if (this.dragEnterCounter === 0) {\n      this.removeDroppingPlaceholder();\n    }\n  };\n\n  onDragEnter = () => {\n    this.dragEnterCounter++;\n  };\n\n  onDrop = (e: Event) => {\n    const { droppingItem } = this.props;\n    const { layout } = this.state;\n    const item = layout.find(l => l.i === droppingItem.i);\n\n    // reset dragEnter counter on drop\n    this.dragEnterCounter = 0;\n\n    this.removeDroppingPlaceholder();\n\n    this.props.onDrop(layout, item, e);\n  };\n\n  render() {\n    const { className, style, isDroppable, innerRef } = this.props;\n\n    const mergedClassName = classNames(layoutClassName, className);\n    const mergedStyle = {\n      height: this.containerHeight(),\n      ...style\n    };\n\n    return (\n      <div\n        ref={innerRef}\n        className={mergedClassName}\n        style={mergedStyle}\n        onDrop={isDroppable ? this.onDrop : noop}\n        onDragLeave={isDroppable ? this.onDragLeave : noop}\n        onDragEnter={isDroppable ? this.onDragEnter : noop}\n        onDragOver={isDroppable ? this.onDragOver : noop}\n      >\n        {React.Children.map(this.props.children, child =>\n          this.processGridItem(child)\n        )}\n        {isDroppable &&\n          this.state.droppingDOMNode &&\n          this.processGridItem(this.state.droppingDOMNode, true)}\n        {this.placeholder()}\n      </div>\n    );\n  }\n}\n\n//        {this.placeholder()}\n","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\lib\\ResponsiveReactGridLayout.jsx",["194","195"],"// @flow\nimport * as React from \"react\";\nimport PropTypes from \"prop-types\";\nimport isEqual from \"lodash.isequal\";\n\nimport {\n  cloneLayout,\n  synchronizeLayoutWithChildren,\n  validateLayout,\n  noop,\n  type Layout\n} from \"./utils\";\nimport {\n  getBreakpointFromWidth,\n  getColsFromBreakpoint,\n  findOrGenerateResponsiveLayout,\n  type ResponsiveLayout,\n  type Breakpoints\n} from \"./responsiveUtils\";\nimport ReactGridLayout from \"./ReactGridLayout\";\n\nconst type = obj => Object.prototype.toString.call(obj);\n\n/**\n * Get a value of margin or containerPadding.\n *\n * @param  {Array | Object} param Margin | containerPadding, e.g. [10, 10] | {lg: [10, 10], ...}.\n * @param  {String} breakpoint   Breakpoint: lg, md, sm, xs and etc.\n * @return {Array}\n */\n\nfunction getIndentationValue<T: ?[number, number]>(\n  param: { [key: string]: T } | T,\n  breakpoint: string\n): T {\n  // $FlowIssue doesn't seem to understand this\n  if (param == null) return null;\n  return Array.isArray(param) ? param : param[breakpoint];\n}\n\ntype State = {\n  layout: Layout,\n  breakpoint: string,\n  cols: number,\n  layouts?: { [key: string]: Layout }\n};\n\ntype Props<Breakpoint: string = string> = {|\n  ...React.ElementConfig<typeof ReactGridLayout>,\n\n  // Responsive config\n  breakpoint?: ?Breakpoint,\n  breakpoints: Breakpoints<Breakpoint>,\n  cols: { [key: Breakpoint]: number },\n  layouts: ResponsiveLayout<Breakpoint>,\n  width: number,\n  margin: { [key: Breakpoint]: [number, number] } | [number, number],\n  /* prettier-ignore */\n  containerPadding: { [key: Breakpoint]: ?[number, number] } | ?[number, number],\n\n  // Callbacks\n  onBreakpointChange: (Breakpoint, cols: number) => void,\n  onLayoutChange: (Layout, { [key: Breakpoint]: Layout }) => void,\n  onWidthChange: (\n    containerWidth: number,\n    margin: [number, number],\n    cols: number,\n    containerPadding: ?[number, number]\n  ) => void\n|};\n\nexport default class ResponsiveReactGridLayout extends React.Component<\n  Props<>,\n  State\n> {\n  // This should only include propTypes needed in this code; RGL itself\n  // will do validation of the rest props passed to it.\n  static propTypes = {\n    //\n    // Basic props\n    //\n\n    // Optional, but if you are managing width yourself you may want to set the breakpoint\n    // yourself as well.\n    breakpoint: PropTypes.string,\n\n    // {name: pxVal}, e.g. {lg: 1200, md: 996, sm: 768, xs: 480}\n    breakpoints: PropTypes.object,\n\n    // # of cols. This is a breakpoint -> cols map\n    cols: PropTypes.object,\n\n    // # of margin. This is a breakpoint -> margin map\n    // e.g. { lg: [5, 5], md: [10, 10], sm: [15, 15] }\n    // Margin between items [x, y] in px\n    // e.g. [10, 10]\n    margin: PropTypes.oneOfType([PropTypes.array, PropTypes.object]),\n\n    // # of containerPadding. This is a breakpoint -> containerPadding map\n    // e.g. { lg: [5, 5], md: [10, 10], sm: [15, 15] }\n    // Padding inside the container [x, y] in px\n    // e.g. [10, 10]\n    containerPadding: PropTypes.oneOfType([PropTypes.array, PropTypes.object]),\n\n    // layouts is an object mapping breakpoints to layouts.\n    // e.g. {lg: Layout, md: Layout, ...}\n    layouts(props: Props<>, propName: string) {\n      if (type(props[propName]) !== \"[object Object]\") {\n        throw new Error(\n          \"Layout property must be an object. Received: \" +\n            type(props[propName])\n        );\n      }\n      Object.keys(props[propName]).forEach(key => {\n        if (!(key in props.breakpoints)) {\n          throw new Error(\n            \"Each key in layouts must align with a key in breakpoints.\"\n          );\n        }\n        validateLayout(props.layouts[key], \"layouts.\" + key);\n      });\n    },\n\n    // The width of this component.\n    // Required in this propTypes stanza because generateInitialState() will fail without it.\n    width: PropTypes.number.isRequired,\n\n    //\n    // Callbacks\n    //\n\n    // Calls back with breakpoint and new # cols\n    onBreakpointChange: PropTypes.func,\n\n    // Callback so you can save the layout.\n    // Calls back with (currentLayout, allLayouts). allLayouts are keyed by breakpoint.\n    onLayoutChange: PropTypes.func,\n\n    // Calls back with (containerWidth, margin, cols, containerPadding)\n    onWidthChange: PropTypes.func\n  };\n\n  constructor(props: Props, context: any): void {\n    super(props, context);\n    //console.log(props)\n  }\n\n  static defaultProps = {\n    breakpoints: { lg: 1200, md: 996, sm: 768, xs: 480, xxs: 0 },\n    cols: { lg: 12, md: 10, sm: 6, xs: 4, xxs: 2 },\n    layouts: {},\n    margin: [10, 10],\n    containerPadding: { lg: null, md: null, sm: null, xs: null, xxs: null },\n    onBreakpointChange: noop,\n    onLayoutChange: noop,\n    onWidthChange: noop\n  };\n\n  state = this.generateInitialState();\n\n  generateInitialState(): State {\n    console.log('generateInitialState')\n    const { width, breakpoints, layouts, cols } = this.props;\n    const breakpoint = getBreakpointFromWidth(breakpoints, width);\n    const colNo = getColsFromBreakpoint(breakpoint, cols);\n    // verticalCompact compatibility, now deprecated\n    const compactType =\n      this.props.verticalCompact === false ? null : this.props.compactType;\n    // Get the initial layout. This can tricky; we try to generate one however possible if one doesn't exist\n    // for this layout.\n    //console.log('a',layouts)\n    const initialLayout = findOrGenerateResponsiveLayout(\n      layouts,\n      breakpoints,\n      breakpoint,\n      breakpoint,\n      colNo,\n      compactType\n    );\n\n    //console.log('b',initialLayout)\n    return {\n      layout: initialLayout,\n      breakpoint: breakpoint,\n      cols: colNo\n    };\n  }\n\n  static getDerivedStateFromProps(nextProps: Props<*>, prevState: State) {\n    if (!isEqual(nextProps.layouts, prevState.layouts)) {\n      // Allow parent to set layouts directly.\n      const { breakpoint, cols } = prevState;\n\n      // Since we're setting an entirely new layout object, we must generate a new responsive layout\n      // if one does not exist.\n      const newLayout = findOrGenerateResponsiveLayout(\n        nextProps.layouts,\n        nextProps.breakpoints,\n        breakpoint,\n        breakpoint,\n        cols,\n        nextProps.compactType\n      );\n      return { layout: newLayout, layouts: nextProps.layouts };\n    }\n\n    return null;\n  }\n\n  componentDidUpdate(prevProps: Props<*>) {\n    // Allow parent to set width or breakpoint directly.\n    if (\n      this.props.width != prevProps.width ||\n      this.props.breakpoint !== prevProps.breakpoint ||\n      !isEqual(this.props.breakpoints, prevProps.breakpoints) ||\n      !isEqual(this.props.cols, prevProps.cols)\n    ) {\n      this.onWidthChange(prevProps);\n    }\n  }\n\n  // wrap layouts so we do not need to pass layouts to child\n  onLayoutChange = (layout: Layout) => {\n    this.props.onLayoutChange(layout, {\n      ...this.props.layouts,\n      [this.state.breakpoint]: layout\n    });\n  };\n\n  /**\n   * When the width changes work through breakpoints and reset state with the new width & breakpoint.\n   * Width changes are necessary to figure out the widget widths.\n   */\n  onWidthChange(prevProps: Props<*>) {\n    console.log('onWidthChange')\n    console.log(this.props.width)\n    console.log(this.props)\n    var type = 'width' + this.props.level\n    var payload = this.props.width\n    window.dispatchEvent(new CustomEvent('mjg',{detail:{type:type,payload:payload}}));\n\n\n\n\n    const { breakpoints, cols, layouts, compactType } = this.props;\n    const newBreakpoint =\n      this.props.breakpoint ||\n      getBreakpointFromWidth(this.props.breakpoints, this.props.width);\n\n    const lastBreakpoint = this.state.breakpoint;\n    const newCols: number = getColsFromBreakpoint(newBreakpoint, cols);\n    const newLayouts = { ...layouts };\n\n    // Breakpoint change\n    if (\n      lastBreakpoint !== newBreakpoint ||\n      prevProps.breakpoints !== breakpoints ||\n      prevProps.cols !== cols\n    ) {\n      // Preserve the current layout if the current breakpoint is not present in the next layouts.\n      if (!(lastBreakpoint in newLayouts))\n        newLayouts[lastBreakpoint] = cloneLayout(this.state.layout);\n\n      // Find or generate a new layout.\n      let layout = findOrGenerateResponsiveLayout(\n        newLayouts,\n        breakpoints,\n        newBreakpoint,\n        lastBreakpoint,\n        newCols,\n        compactType\n      );\n\n      // This adds missing items.\n      layout = synchronizeLayoutWithChildren(\n        layout,\n        this.props.children,\n        newCols,\n        compactType\n      );\n\n      // Store the new layout.\n      newLayouts[newBreakpoint] = layout;\n\n      // callbacks\n      this.props.onLayoutChange(layout, newLayouts);\n      this.props.onBreakpointChange(newBreakpoint, newCols);\n\n      this.setState({\n        breakpoint: newBreakpoint,\n        layout: layout,\n        cols: newCols\n      });\n    }\n\n    const margin = getIndentationValue(this.props.margin, newBreakpoint);\n    const containerPadding = getIndentationValue(\n      this.props.containerPadding,\n      newBreakpoint\n    );\n\n    //call onWidthChange on every change of width, not only on breakpoint changes\n    this.props.onWidthChange(\n      this.props.width,\n      margin,\n      newCols,\n      containerPadding\n    );\n  }\n\n  render() {\n    /* eslint-disable no-unused-vars */\n    const {\n      breakpoint,\n      breakpoints,\n      cols,\n      layouts,\n      margin,\n      containerPadding,\n      onBreakpointChange,\n      onLayoutChange,\n      onWidthChange,\n      ...other\n    } = this.props;\n    /* eslint-enable no-unused-vars */\n    //console.log('props',this.props)\n\n    return (\n      <ReactGridLayout\n        {...other}\n        margin={getIndentationValue(margin, this.state.breakpoint)}\n        containerPadding={getIndentationValue(\n          containerPadding,\n          this.state.breakpoint\n        )}\n        onLayoutChange={this.onLayoutChange}\n        layout={this.state.layout}\n        cols={this.state.cols}\n      />\n    );\n  }\n}\n","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\lib\\components\\WidthProvider.jsx",[],"C:\\work\\React\\rgl-test\\src\\react-grid-layout\\lib\\fastRGLPropsEqual.js",["196"],"// @preval\n\nrequire(\"@babel/register\");\n\n// Fast way to compare RGL props in shouldComponentUpdate.\n// Generates the fastest possible comparison of the type:\n// function (a, b) { return a.className === b.className && a.style === b.style && ... }\n// This avoids enumerating keys, avoids us keeping our own key list, and can be very easily optimized.\n\nconst PropTypes = require(\"prop-types\");\nconst propTypes = require(\"./ReactGridLayoutPropTypes\").default;\nconst keys = Object.keys(propTypes);\n\n// Remove 'children' key as we don't want to compare it\nkeys.splice(keys.indexOf(\"children\"), 1);\n\n// Returns a code string indicating what to do here.\n// In most cases we want to do a simple equality comparison,\n// but we have some arrays and tuples and objects we want\n// to do a shallow comparison on.\nfunction getEqualType(key) {\n  if (\n    [\n      PropTypes.number,\n      PropTypes.bool,\n      PropTypes.string,\n      PropTypes.func\n    ].includes(propTypes[key])\n  ) {\n    return `(a.${key} === b.${key})`;\n  }\n  return `isEqualImpl(a.${key}, b.${key})`;\n}\n\n// Exports a function that compares a and b. `isEqualImpl` is a required\n// third prop, as we can't otherwise access it.\nmodule.exports = () =>\n  eval(`\n  function fastRGLPropsEqual(a, b, isEqualImpl) {\n    if (a === b) return true;\n    return (\n      ${keys.map(getEqualType).join(\" && \")}\n    );\n  }\n  fastRGLPropsEqual;\n`);\n","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\lib\\ReactGridLayoutPropTypes.js",["197"],"// @flow\nimport PropTypes from \"prop-types\";\nimport React from \"react\";\nimport type {\n  Ref,\n  ChildrenArray as ReactChildrenArray,\n  Element as ReactElement\n} from \"react\";\nimport type { EventCallback, CompactType, Layout, LayoutItem } from \"./utils\";\n\ntype ResizeHandleAxis = \"s\" | \"w\" | \"e\" | \"n\" | \"sw\" | \"nw\" | \"se\" | \"ne\";\nexport type ResizeHandles = Array<ResizeHandleAxis>;\nexport type ResizeHandle =\n  | ReactElement<any>\n  | ((resizeHandleAxis: ResizeHandleAxis) => ReactElement<any>);\n\n// Defines which resize handles should be rendered (default: 'se')\n// Allows for any combination of:\n// 's' - South handle (bottom-center)\n// 'w' - West handle (left-center)\n// 'e' - East handle (right-center)\n// 'n' - North handle (top-center)\n// 'sw' - Southwest handle (bottom-left)\n// 'nw' - Northwest handle (top-left)\n// 'se' - Southeast handle (bottom-right)\n// 'ne' - Northeast handle (top-right)\nexport const resizeHandlesType = PropTypes.arrayOf(\n  PropTypes.oneOf([\"s\", \"w\", \"e\", \"n\", \"sw\", \"nw\", \"se\", \"ne\"])\n);\n// Custom component for resize handles\nexport const resizeHandleType = PropTypes.oneOfType([\n  PropTypes.node,\n  PropTypes.func\n]);\n\nexport type Props = {|\n  className: string,\n  style: Object,\n  width: number,\n  autoSize: boolean,\n  cols: number,\n  draggableCancel: string,\n  draggableHandle: string,\n  verticalCompact: boolean,\n  compactType: CompactType,\n  layout: Layout,\n  margin: [number, number],\n  containerPadding: ?[number, number],\n  rowHeight: number,\n  maxRows: number,\n  isBounded: boolean,\n  isDraggable: boolean,\n  isResizable: boolean,\n  isDroppable: boolean,\n  preventCollision: boolean,\n  useCSSTransforms: boolean,\n  transformScale: number,\n  droppingItem: $Shape<LayoutItem>,\n  resizeHandles: ResizeHandles,\n  resizeHandle?: ResizeHandle,\n\n  // Callbacks\n  onLayoutChange: Layout => void,\n  onDrag: EventCallback,\n  onDragStart: EventCallback,\n  onDragStop: EventCallback,\n  onResize: EventCallback,\n  onResizeStart: EventCallback,\n  onResizeStop: EventCallback,\n  onDrop: (layout: Layout, item: ?LayoutItem, e: Event) => void,\n  children: ReactChildrenArray<ReactElement<any>>,\n  innerRef?: Ref<\"div\">\n|};\n\nexport default {\n  //\n  // Basic props\n  //\n  className: PropTypes.string,\n  style: PropTypes.object,\n\n  // This can be set explicitly. If it is not set, it will automatically\n  // be set to the container width. Note that resizes will *not* cause this to adjust.\n  // If you need that behavior, use WidthProvider.\n  width: PropTypes.number,\n\n  // If true, the container height swells and contracts to fit contents\n  autoSize: PropTypes.bool,\n  // # of cols.\n  cols: PropTypes.number,\n\n  // A selector that will not be draggable.\n  draggableCancel: PropTypes.string,\n  // A selector for the draggable handler\n  draggableHandle: PropTypes.string,\n\n  // Deprecated\n  verticalCompact: function (props: Props) {\n    if (\n      props.verticalCompact === false &&\n      process.env.NODE_ENV !== \"production\"\n    ) {\n      console.warn(\n        // eslint-disable-line no-console\n        \"`verticalCompact` on <ReactGridLayout> is deprecated and will be removed soon. \" +\n          'Use `compactType`: \"horizontal\" | \"vertical\" | null.'\n      );\n    }\n  },\n  // Choose vertical or hotizontal compaction\n  compactType: PropTypes.oneOf([\"vertical\", \"horizontal\"]),\n\n  // layout is an array of object with the format:\n  // {x: Number, y: Number, w: Number, h: Number, i: String}\n  layout: function (props: Props) {\n    var layout = props.layout;\n    // I hope you're setting the data-grid property on the grid items\n    if (layout === undefined) return;\n    require(\"./utils\").validateLayout(layout, \"layout\");\n  },\n\n  //\n  // Grid Dimensions\n  //\n\n  // Margin between items [x, y] in px\n  margin: PropTypes.arrayOf(PropTypes.number),\n  // Padding inside the container [x, y] in px\n  containerPadding: PropTypes.arrayOf(PropTypes.number),\n  // Rows have a static height, but you can change this based on breakpoints if you like\n  rowHeight: PropTypes.number,\n  // Default Infinity, but you can specify a max here if you like.\n  // Note that this isn't fully fleshed out and won't error if you specify a layout that\n  // extends beyond the row capacity. It will, however, not allow users to drag/resize\n  // an item past the barrier. They can push items beyond the barrier, though.\n  // Intentionally not documented for this reason.\n  maxRows: PropTypes.number,\n\n  //\n  // Flags\n  //\n  isBounded: PropTypes.bool,\n  isDraggable: PropTypes.bool,\n  isResizable: PropTypes.bool,\n  // If true, grid items won't change position when being dragged over.\n  preventCollision: PropTypes.bool,\n  // Use CSS transforms instead of top/left\n  useCSSTransforms: PropTypes.bool,\n  // parent layout transform scale\n  transformScale: PropTypes.number,\n  // If true, an external element can trigger onDrop callback with a specific grid position as a parameter\n  isDroppable: PropTypes.bool,\n\n  // Resize handle options\n  resizeHandles: resizeHandlesType,\n  resizeHandle: resizeHandleType,\n\n  //\n  // Callbacks\n  //\n\n  // Callback so you can save the layout. Calls after each drag & resize stops.\n  onLayoutChange: PropTypes.func,\n\n  // Calls when drag starts. Callback is of the signature (layout, oldItem, newItem, placeholder, e, ?node).\n  // All callbacks below have the same signature. 'start' and 'stop' callbacks omit the 'placeholder'.\n  onDragStart: PropTypes.func,\n  // Calls on each drag movement.\n  onDrag: PropTypes.func,\n  // Calls when drag is complete.\n  onDragStop: PropTypes.func,\n  //Calls when resize starts.\n  onResizeStart: PropTypes.func,\n  // Calls when resize movement happens.\n  onResize: PropTypes.func,\n  // Calls when resize is complete.\n  onResizeStop: PropTypes.func,\n  // Calls when some element is dropped.\n  onDrop: PropTypes.func,\n\n  //\n  // Other validations\n  //\n\n  droppingItem: PropTypes.shape({\n    i: PropTypes.string.isRequired,\n    w: PropTypes.number.isRequired,\n    h: PropTypes.number.isRequired\n  }),\n\n  // Children must not have duplicate keys.\n  children: function (props: Props, propName: string) {\n    var children = props[propName];\n\n    // Check children keys for duplicates. Throw if found.\n    var keys = {};\n    React.Children.forEach(children, function (child) {\n      if (keys[child.key]) {\n        throw new Error(\n          'Duplicate child key \"' +\n            child.key +\n            '\" found! This will cause problems in ReactGridLayout.'\n        );\n      }\n      keys[child.key] = true;\n    });\n  },\n\n  // Optional ref for getting a reference for the wrapping div.\n  innerRef: PropTypes.any\n};\n","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\lib\\calculateUtils.js",["198","199"],"// @flow\nimport type { Position } from \"./utils\";\n\nexport type PositionParams = {\n  absoluteLayout: boolean,\n  margin: [number, number],\n  containerPadding: [number, number],\n  containerWidth: number,\n  cols: number,\n  rowHeight: number,\n  maxRows: number\n};\n\n// Helper for generating column width\nexport function calcGridColWidth(positionParams: PositionParams): number {\n  const { margin, containerPadding, containerWidth, cols } = positionParams;\n  return (\n    (containerWidth - margin[0] * (cols - 1) - containerPadding[0] * 2) / cols\n  );\n}\n\n// This can either be called:\n// calcGridItemWHPx(w, colWidth, margin[0])\n// or\n// calcGridItemWHPx(h, rowHeight, margin[1])\nexport function calcGridItemWHPx(\n  gridUnits: number,\n  colOrRowSize: number,\n  marginPx: number\n) {\n  // 0 * Infinity === NaN, which causes problems with resize contraints\n  if (!Number.isFinite(gridUnits)) return gridUnits;\n  return Math.round(\n    colOrRowSize * gridUnits + Math.max(0, gridUnits - 1) * marginPx\n  );\n}\n\n/**\n * Return position on the page given an x, y, w, h.\n * left, top, width, height are all in pixels.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\n * @param  {Number}  x                      X coordinate in grid units.\n * @param  {Number}  y                      Y coordinate in grid units.\n * @param  {Number}  w                      W coordinate in grid units.\n * @param  {Number}  h                      H coordinate in grid units.\n * @return {Position}                       Object containing coords.\n */\nexport function calcGridItemPosition(\n  positionParams: PositionParams,\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  state: ?Object\n): Position {\n  const { margin, containerPadding, rowHeight } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n  const out = {};\n\n  //console.log(state)\n\n  // If resizing, use the exact width and height as returned from resizing callbacks.\n  if (state && state.resizing) {\n    out.width = Math.round(state.resizing.width);\n    out.height = Math.round(state.resizing.height);\n  }\n  // Otherwise, calculate from grid units.\n  else {\n    out.width = calcGridItemWHPx(w, colWidth, margin[0]);\n    out.height = calcGridItemWHPx(h, rowHeight, margin[1]);\n  }\n\n  // If dragging, use the exact width and height as returned from dragging callbacks.\n  if (state && state.dragging) {\n    out.top = Math.round(state.dragging.top);\n    out.left = Math.round(state.dragging.left);\n  }\n  // Otherwise, calculate from grid units.\n  else {\n    if (positionParams.absoluteLayout == true) {\n\n    }\n    else {\n    out.top = Math.round((rowHeight + margin[1]) * y + containerPadding[1]);\n    out.left = Math.round((colWidth + margin[0]) * x + containerPadding[0]);\n  }\n  }\n\n  return out;\n}\n\n/**\n * Translate x and y coordinates from pixels to grid units.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\n * @param  {Number} top                     Top position (relative to parent) in pixels.\n * @param  {Number} left                    Left position (relative to parent) in pixels.\n * @param  {Number} w                       W coordinate in grid units.\n * @param  {Number} h                       H coordinate in grid units.\n * @return {Object}                         x and y in grid units.\n */\nexport function calcXY(\n  positionParams: PositionParams,\n  top: number,\n  left: number,\n  w: number,\n  h: number\n): { x: number, y: number } {\n  const { margin, cols, rowHeight, maxRows } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n\n  if (positionParams.absoluteLayout == true) {\n    return { left, top }\n  }\n\n  // left = colWidth * x + margin * (x + 1)\n  // l = cx + m(x+1)\n  // l = cx + mx + m\n  // l - m = cx + mx\n  // l - m = x(c + m)\n  // (l - m) / (c + m) = x\n  // x = (left - margin) / (coldWidth + margin)\n  let x = Math.round((left - margin[0]) / (colWidth + margin[0]));\n  let y = Math.round((top - margin[1]) / (rowHeight + margin[1]));\n\n  // Capping\n  x = clamp(x, 0, cols - w);\n  y = clamp(y, 0, maxRows - h);\n  return { x, y };\n}\n\n/**\n * Given a height and width in pixel values, calculate grid units.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calcluations.\n * @param  {Number} height                  Height in pixels.\n * @param  {Number} width                   Width in pixels.\n * @param  {Number} x                       X coordinate in grid units.\n * @param  {Number} y                       Y coordinate in grid units.\n * @return {Object}                         w, h as grid units.\n */\nexport function calcWH(\n  positionParams: PositionParams,\n  width: number,\n  height: number,\n  x: number,\n  y: number\n): { w: number, h: number } {\n  const { margin, maxRows, cols, rowHeight } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n\n  // width = colWidth * w - (margin * (w - 1))\n  // ...\n  // w = (width + margin) / (colWidth + margin)\n  let w = Math.round((width + margin[0]) / (colWidth + margin[0]));\n  let h = Math.round((height + margin[1]) / (rowHeight + margin[1]));\n\n  // Capping\n  w = clamp(w, 0, cols - x);\n  h = clamp(h, 0, maxRows - y);\n  return { w, h };\n}\n\n// Similar to _.clamp\nexport function clamp(num: number, lowerBound: number, upperBound: number) {\n  return Math.max(Math.min(num, upperBound), lowerBound);\n}\n","C:\\work\\React\\rgl-test\\src\\react-grid-layout\\lib\\GridItem.jsx",["200"],"// @flow\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport PropTypes from \"prop-types\";\nimport { DraggableCore } from \"react-draggable\";\nimport { Resizable } from \"react-resizable\";\nimport { fastPositionEqual, perc, setTopLeft, setTransform } from \"./utils\";\nimport {\n  calcGridItemPosition,\n  calcGridItemWHPx,\n  calcGridColWidth,\n  calcXY,\n  calcWH,\n  clamp\n} from \"./calculateUtils\";\nimport {\n  resizeHandlesType,\n  resizeHandleType\n} from \"./ReactGridLayoutPropTypes\";\nimport classNames from \"classnames\";\nimport type { Element as ReactElement, Node as ReactNode } from \"react\";\n\nimport type {\n  ReactDraggableCallbackData,\n  GridDragEvent,\n  GridResizeEvent,\n  DroppingPosition,\n  Position\n} from \"./utils\";\n\nimport type { PositionParams } from \"./calculateUtils\";\nimport type { ResizeHandles, ResizeHandle } from \"./ReactGridLayoutPropTypes\";\n\ntype PartialPosition = { top: number, left: number };\ntype GridItemCallback<Data: GridDragEvent | GridResizeEvent> = (\n  i: string,\n  w: number,\n  h: number,\n  Data\n) => void;\n\ntype State = {\n  resizing: ?{ width: number, height: number },\n  dragging: ?{ top: number, left: number },\n  className: string\n};\n\ntype Props = {\n  absoluteLayout: boolean,\n  children: ReactElement<any>,\n  cols: number,\n  containerWidth: number,\n  margin: [number, number],\n  containerPadding: [number, number],\n  rowHeight: number,\n  maxRows: number,\n  isDraggable: boolean,\n  isResizable: boolean,\n  isBounded: boolean,\n  static?: boolean,\n  useCSSTransforms?: boolean,\n  usePercentages?: boolean,\n  transformScale: number,\n  droppingPosition?: DroppingPosition,\n\n  className: string,\n  style?: Object,\n  // Draggability\n  cancel: string,\n  handle: string,\n\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n\n  minW: number,\n  maxW: number,\n  minH: number,\n  maxH: number,\n  i: string,\n\n  resizeHandles?: ResizeHandles,\n  resizeHandle?: ResizeHandle,\n\n  onDrag?: GridItemCallback<GridDragEvent>,\n  onDragStart?: GridItemCallback<GridDragEvent>,\n  onDragStop?: GridItemCallback<GridDragEvent>,\n  onResize?: GridItemCallback<GridResizeEvent>,\n  onResizeStart?: GridItemCallback<GridResizeEvent>,\n  onResizeStop?: GridItemCallback<GridResizeEvent>\n};\n\n/**\n * An individual item within a ReactGridLayout.\n */\nexport default class GridItem extends React.Component<Props, State> {\n  static propTypes = {\n    //absoluteLayout: PropTypes.boolean.isRequired,\n    // Children must be only a single element\n    children: PropTypes.element,\n\n    // General grid attributes\n    cols: PropTypes.number.isRequired,\n    containerWidth: PropTypes.number.isRequired,\n    rowHeight: PropTypes.number.isRequired,\n    margin: PropTypes.array.isRequired,\n    maxRows: PropTypes.number.isRequired,\n    containerPadding: PropTypes.array.isRequired,\n\n    // These are all in grid units\n    x: PropTypes.number.isRequired,\n    y: PropTypes.number.isRequired,\n    w: PropTypes.number.isRequired,\n    h: PropTypes.number.isRequired,\n\n    // All optional\n    minW: function (props: Props, propName: string) {\n      const value = props[propName];\n      if (typeof value !== \"number\") return new Error(\"minWidth not Number\");\n      if (value > props.w || value > props.maxW)\n        return new Error(\"minWidth larger than item width/maxWidth\");\n    },\n\n    maxW: function (props: Props, propName: string) {\n      const value = props[propName];\n      if (typeof value !== \"number\") return new Error(\"maxWidth not Number\");\n      if (value < props.w || value < props.minW)\n        return new Error(\"maxWidth smaller than item width/minWidth\");\n    },\n\n    minH: function (props: Props, propName: string) {\n      const value = props[propName];\n      if (typeof value !== \"number\") return new Error(\"minHeight not Number\");\n      if (value > props.h || value > props.maxH)\n        return new Error(\"minHeight larger than item height/maxHeight\");\n    },\n\n    maxH: function (props: Props, propName: string) {\n      const value = props[propName];\n      if (typeof value !== \"number\") return new Error(\"maxHeight not Number\");\n      if (value < props.h || value < props.minH)\n        return new Error(\"maxHeight smaller than item height/minHeight\");\n    },\n\n    // ID is nice to have for callbacks\n    i: PropTypes.string.isRequired,\n\n    // Resize handle options\n    resizeHandles: resizeHandlesType,\n    resizeHandle: resizeHandleType,\n\n    // Functions\n    onDragStop: PropTypes.func,\n    onDragStart: PropTypes.func,\n    onDrag: PropTypes.func,\n    onResizeStop: PropTypes.func,\n    onResizeStart: PropTypes.func,\n    onResize: PropTypes.func,\n\n    // Flags\n    isDraggable: PropTypes.bool.isRequired,\n    isResizable: PropTypes.bool.isRequired,\n    isBounded: PropTypes.bool.isRequired,\n    static: PropTypes.bool,\n\n    // Use CSS transforms instead of top/left\n    useCSSTransforms: PropTypes.bool.isRequired,\n    transformScale: PropTypes.number,\n\n    // Others\n    className: PropTypes.string,\n    // Selector for draggable handle\n    handle: PropTypes.string,\n    // Selector for draggable cancel (see react-draggable)\n    cancel: PropTypes.string,\n    // Current position of a dropping element\n    droppingPosition: PropTypes.shape({\n      e: PropTypes.object.isRequired,\n      left: PropTypes.number.isRequired,\n      top: PropTypes.number.isRequired\n    })\n  };\n\n  static defaultProps = {\n    className: \"\",\n    cancel: \"\",\n    handle: \"\",\n    minH: 1,\n    minW: 1,\n    maxH: Infinity,\n    maxW: Infinity,\n    transformScale: 1\n  };\n\n  state: State = {\n    resizing: null,\n    dragging: null,\n    className: \"\"\n  };\n\n  currentNode: HTMLElement;\n\n  shouldComponentUpdate(nextProps: Props, nextState: State) {\n    // We can't deeply compare children. If the developer memoizes them, we can\n    // use this optimization.\n    if (this.props.children !== nextProps.children) return true;\n    if (this.props.droppingPosition !== nextProps.droppingPosition) return true;\n    // TODO memoize these calculations so they don't take so long?\n    const oldPosition = calcGridItemPosition(\n      this.getPositionParams(this.props),\n      this.props.x,\n      this.props.y,\n      this.props.w,\n      this.props.h,\n      this.state\n    );\n    const newPosition = calcGridItemPosition(\n      this.getPositionParams(nextProps),\n      nextProps.x,\n      nextProps.y,\n      nextProps.w,\n      nextProps.h,\n      nextState\n    );\n    return (\n      !fastPositionEqual(oldPosition, newPosition) ||\n      this.props.useCSSTransforms !== nextProps.useCSSTransforms\n    );\n  }\n\n  componentDidMount() {\n    this.moveDroppingItem({});\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    console.log('componentDidUpdate')\n    this.moveDroppingItem(prevProps);\n  }\n\n  // When a droppingPosition is present, this means we should fire a move event, as if we had moved\n  // this element by `x, y` pixels.\n  moveDroppingItem(prevProps: Props) {\n    const { droppingPosition } = this.props;\n    if (!droppingPosition) return;\n\n    const prevDroppingPosition = prevProps.droppingPosition || {\n      left: 0,\n      top: 0\n    };\n    const { dragging } = this.state;\n\n    if (!this.currentNode) {\n      // eslint-disable-next-line react/no-find-dom-node\n      this.currentNode = ((ReactDOM.findDOMNode(this): any): HTMLElement);\n    }\n\n    const shouldDrag =\n      (dragging && droppingPosition.left !== prevDroppingPosition.left) ||\n      droppingPosition.top !== prevDroppingPosition.top;\n\n    if (!dragging) {\n      this.onDragStart(droppingPosition.e, {\n        node: this.currentNode,\n        deltaX: droppingPosition.left,\n        deltaY: droppingPosition.top\n      });\n    } else if (shouldDrag) {\n      const deltaX = droppingPosition.left - dragging.left;\n      const deltaY = droppingPosition.top - dragging.top;\n\n      this.onDrag(droppingPosition.e, {\n        node: this.currentNode,\n        deltaX,\n        deltaY\n      });\n    }\n  }\n\n  getPositionParams(props: Props = this.props): PositionParams {\n    return {\n      absoluteLayout: props.absoluteLayout,\n      cols: props.cols,\n      containerPadding: props.containerPadding,\n      containerWidth: props.containerWidth,\n      margin: props.margin,\n      maxRows: props.maxRows,\n      rowHeight: props.rowHeight\n    };\n  }\n\n  /**\n   * This is where we set the grid item's absolute placement. It gets a little tricky because we want to do it\n   * well when server rendering, and the only way to do that properly is to use percentage width/left because\n   * we don't know exactly what the browser viewport is.\n   * Unfortunately, CSS Transforms, which are great for performance, break in this instance because a percentage\n   * left is relative to the item itself, not its container! So we cannot use them on the server rendering pass.\n   *\n   * @param  {Object} pos Position object with width, height, left, top.\n   * @return {Object}     Style object.\n   */\n  createStyle(pos: Position): { [key: string]: ?string } {\n    const { usePercentages, containerWidth, useCSSTransforms } = this.props;\n\n    let style;\n    // CSS Transforms support (default)\n    if (useCSSTransforms) {\n      style = setTransform(pos);\n    } else {\n      // top,left (slow)\n      style = setTopLeft(pos);\n\n      // This is used for server rendering.\n      if (usePercentages) {\n        style.left = perc(pos.left / containerWidth);\n        style.width = perc(pos.width / containerWidth);\n      }\n    }\n\n    return style;\n  }\n\n  /**\n   * Mix a Draggable instance into a child.\n   * @param  {Element} child    Child element.\n   * @return {Element}          Child wrapped in Draggable.\n   */\n  mixinDraggable(\n    child: ReactElement<any>,\n    isDraggable: boolean\n  ): ReactElement<any> {\n    return (\n      <DraggableCore\n        disabled={!isDraggable}\n        onStart={this.onDragStart}\n        onDrag={this.onDrag}\n        onStop={this.onDragStop}\n        handle={this.props.handle}\n        cancel={\n          \".react-resizable-handle\" +\n          (this.props.cancel ? \",\" + this.props.cancel : \"\")\n        }\n        scale={this.props.transformScale}\n      >\n        {child}\n      </DraggableCore>\n    );\n  }\n\n  /**\n   * Mix a Resizable instance into a child.\n   * @param  {Element} child    Child element.\n   * @param  {Object} position  Position object (pixel values)\n   * @return {Element}          Child wrapped in Resizable.\n   */\n  mixinResizable(\n    child: ReactElement<any>,\n    position: Position,\n    isResizable: boolean\n  ): ReactElement<any> {\n    const {\n      cols,\n      x,\n      minW,\n      minH,\n      maxW,\n      maxH,\n      transformScale,\n      resizeHandles,\n      resizeHandle\n    } = this.props;\n    const positionParams = this.getPositionParams();\n\n    // This is the max possible width - doesn't go to infinity because of the width of the window\n    const maxWidth = calcGridItemPosition(positionParams, 0, 0, cols - x, 0)\n      .width;\n\n    // Calculate min/max constraints using our min & maxes\n    const mins = calcGridItemPosition(positionParams, 0, 0, minW, minH);\n    const maxes = calcGridItemPosition(positionParams, 0, 0, maxW, maxH);\n    const minConstraints = [mins.width, mins.height];\n    const maxConstraints = [\n      Math.min(maxes.width, maxWidth),\n      Math.min(maxes.height, Infinity)\n    ];\n    return (\n      <Resizable\n        draggableOpts={{\n          disabled: !isResizable\n        }}\n        className={isResizable ? undefined : \"react-resizable-hide\"}\n        width={position.width}\n        height={position.height}\n        minConstraints={minConstraints}\n        maxConstraints={maxConstraints}\n        onResizeStop={this.onResizeStop}\n        onResizeStart={this.onResizeStart}\n        onResize={this.onResize}\n        transformScale={transformScale}\n        resizeHandles={resizeHandles}\n        handle={resizeHandle}\n      >\n        {child}\n      </Resizable>\n    );\n  }\n\n  /**\n   * onDragStart event handler\n   * @param  {Event}  e             event data\n   * @param  {Object} callbackData  an object with node, delta and position information\n   */\n  onDragStart = (e: Event, { node }: ReactDraggableCallbackData) => {\n    const { onDragStart } = this.props;\n    if (!onDragStart) return;\n\n    const newPosition: PartialPosition = { top: 0, left: 0 };\n\n    // TODO: this wont work on nested parents\n    const { offsetParent } = node;\n    if (!offsetParent) return;\n    const parentRect = offsetParent.getBoundingClientRect();\n    const clientRect = node.getBoundingClientRect();\n    const cLeft = clientRect.left / this.props.transformScale;\n    const pLeft = parentRect.left / this.props.transformScale;\n    const cTop = clientRect.top / this.props.transformScale;\n    const pTop = parentRect.top / this.props.transformScale;\n    newPosition.left = cLeft - pLeft + offsetParent.scrollLeft;\n    newPosition.top = cTop - pTop + offsetParent.scrollTop;\n    this.setState({ dragging: newPosition });\n\n    // Call callback with this data\n    const { x, y } = calcXY(\n      this.getPositionParams(),\n      newPosition.top,\n      newPosition.left,\n      this.props.w,\n      this.props.h\n    );\n\n    return onDragStart.call(this, this.props.i, x, y, {\n      e,\n      node,\n      newPosition\n    });\n  };\n\n  /**\n   * onDrag event handler\n   * @param  {Event}  e             event data\n   * @param  {Object} callbackData  an object with node, delta and position information\n   */\n  onDrag = (e: Event, { node, deltaX, deltaY }: ReactDraggableCallbackData) => {\n    const { onDrag, transformScale } = this.props;\n    if (!onDrag) return;\n    deltaX /= transformScale;\n    deltaY /= transformScale;\n\n    if (!this.state.dragging) {\n      throw new Error(\"onDrag called before onDragStart.\");\n    }\n    let top = this.state.dragging.top + deltaY;\n    let left = this.state.dragging.left + deltaX;\n\n    const { isBounded, i, w, h, containerWidth } = this.props;\n    const positionParams = this.getPositionParams();\n\n    // Boundary calculations; keeps items within the grid\n    if (isBounded) {\n      const { offsetParent } = node;\n\n      if (offsetParent) {\n        const { margin, rowHeight } = this.props;\n        const bottomBoundary =\n          offsetParent.clientHeight - calcGridItemWHPx(h, rowHeight, margin[1]);\n        top = clamp(top, 0, bottomBoundary);\n\n        const colWidth = calcGridColWidth(positionParams);\n        const rightBoundary =\n          containerWidth - calcGridItemWHPx(w, colWidth, margin[0]);\n        left = clamp(left, 0, rightBoundary);\n      }\n    }\n\n    const newPosition: PartialPosition = { top, left };\n    this.setState({ dragging: newPosition });\n\n    // Call callback with this data\n    const { x, y } = calcXY(positionParams, top, left, w, h);\n    return onDrag.call(this, i, x, y, {\n      e,\n      node,\n      newPosition\n    });\n  };\n\n  /**\n   * onDragStop event handler\n   * @param  {Event}  e             event data\n   * @param  {Object} callbackData  an object with node, delta and position information\n   */\n  onDragStop = (e: Event, { node }: ReactDraggableCallbackData) => {\n    const { onDragStop } = this.props;\n    if (!onDragStop) return;\n\n    if (!this.state.dragging) {\n      throw new Error(\"onDragEnd called before onDragStart.\");\n    }\n    const { w, h, i } = this.props;\n    const { left, top } = this.state.dragging;\n    const newPosition: PartialPosition = { top, left };\n    this.setState({ dragging: null });\n\n    const { x, y } = calcXY(this.getPositionParams(), top, left, w, h);\n\n    return onDragStop.call(this, i, x, y, {\n      e,\n      node,\n      newPosition\n    });\n  };\n\n  /**\n   * onResizeStop event handler\n   * @param  {Event}  e             event data\n   * @param  {Object} callbackData  an object with node and size information\n   */\n  onResizeStop = (\n    e: Event,\n    callbackData: { node: HTMLElement, size: Position }\n  ) => {\n    this.onResizeHandler(e, callbackData, \"onResizeStop\");\n  };\n\n  /**\n   * onResizeStart event handler\n   * @param  {Event}  e             event data\n   * @param  {Object} callbackData  an object with node and size information\n   */\n  onResizeStart = (\n    e: Event,\n    callbackData: { node: HTMLElement, size: Position }\n  ) => {\n    this.onResizeHandler(e, callbackData, \"onResizeStart\");\n  };\n\n  /**\n   * onResize event handler\n   * @param  {Event}  e             event data\n   * @param  {Object} callbackData  an object with node and size information\n   */\n  onResize = (\n    e: Event,\n    callbackData: { node: HTMLElement, size: Position }\n  ) => {\n    this.onResizeHandler(e, callbackData, \"onResize\");\n  };\n\n  /**\n   * Wrapper around drag events to provide more useful data.\n   * All drag events call the function with the given handler name,\n   * with the signature (index, x, y).\n   *\n   * @param  {String} handlerName Handler name to wrap.\n   * @return {Function}           Handler function.\n   */\n  onResizeHandler(\n    e: Event,\n    { node, size }: { node: HTMLElement, size: Position },\n    handlerName: string\n  ) {\n    const handler = this.props[handlerName];\n    if (!handler) return;\n    const { cols, x, y, i, maxH, minH } = this.props;\n    let { minW, maxW } = this.props;\n\n    // Get new XY\n    let { w, h } = calcWH(\n      this.getPositionParams(),\n      size.width,\n      size.height,\n      x,\n      y\n    );\n\n    // minW should be at least 1 (TODO propTypes validation?)\n    minW = Math.max(minW, 1);\n\n    // maxW should be at most (cols - x)\n    maxW = Math.min(maxW, cols - x);\n\n    // Min/max capping\n    w = clamp(w, minW, maxW);\n    h = clamp(h, minH, maxH);\n\n    this.setState({ resizing: handlerName === \"onResizeStop\" ? null : size });\n\n    handler.call(this, i, w, h, { e, node, size });\n  }\n\n  render(): ReactNode {\n    const {\n      x,\n      y,\n      w,\n      h,\n      isDraggable,\n      isResizable,\n      droppingPosition,\n      useCSSTransforms\n    } = this.props;\n\n    console.log(this.props)\n    var absoluteStyle = {}\n    if (this.props.absoluteLayout == true) {\n      // absoluteStyle.zIndex = '300',\n      // absoluteStyle.border = '3px solid red'\n    }\n\n    const pos = calcGridItemPosition(\n      this.getPositionParams(),\n      x,\n      y,\n      w,\n      h,\n      this.state\n    );\n    const child = React.Children.only(this.props.children);\n\n    // Create the child element. We clone the existing element but modify its className and style.\n    let newChild = React.cloneElement(child, {\n      className: classNames(\n        \"react-grid-item\",\n        child.props.className,\n        this.props.className,\n        {\n          static: this.props.static,\n          resizing: Boolean(this.state.resizing),\n          \"react-draggable\": isDraggable,\n          \"react-draggable-dragging\": Boolean(this.state.dragging),\n          dropping: Boolean(droppingPosition),\n          cssTransforms: useCSSTransforms\n        }\n      ),\n      // We can set the width and height on the child, but unfortunately we can't set the position.\n      style: {\n        ...absoluteStyle,\n        ...this.props.style,\n        ...child.props.style,\n        ...this.createStyle(pos)\n      }\n    });\n\n    // Resizable support. This is usually on but the user can toggle it off.\n    newChild = this.mixinResizable(newChild, pos, isResizable);\n\n    // Draggable support. This is always on, except for with placeholders.\n    newChild = this.mixinDraggable(newChild, isDraggable);\n\n    return newChild;\n  }\n}\n",{"ruleId":"201","severity":1,"message":"202","line":3,"column":10,"nodeType":"203","messageId":"204","endLine":3,"endColumn":15},{"ruleId":"201","severity":1,"message":"205","line":3,"column":17,"nodeType":"203","messageId":"204","endLine":3,"endColumn":23},{"ruleId":"201","severity":1,"message":"206","line":3,"column":25,"nodeType":"203","messageId":"204","endLine":3,"endColumn":36},{"ruleId":"201","severity":1,"message":"207","line":3,"column":38,"nodeType":"203","messageId":"204","endLine":3,"endColumn":48},{"ruleId":"201","severity":1,"message":"208","line":8,"column":25,"nodeType":"203","messageId":"204","endLine":8,"endColumn":30},{"ruleId":"201","severity":1,"message":"209","line":8,"column":33,"nodeType":"203","messageId":"204","endLine":8,"endColumn":41},{"ruleId":"210","severity":1,"message":"211","line":42,"column":6,"nodeType":"212","endLine":42,"endColumn":8,"suggestions":"213"},{"ruleId":"214","replacedBy":"215"},{"ruleId":"216","replacedBy":"217"},{"ruleId":"201","severity":1,"message":"218","line":238,"column":15,"nodeType":"203","messageId":"204","endLine":238,"endColumn":21},{"ruleId":"219","severity":1,"message":"220","line":284,"column":76,"nodeType":"221","messageId":"222","endLine":284,"endColumn":78},{"ruleId":"223","severity":1,"message":"224","line":1,"column":1,"nodeType":"225","messageId":"226","endLine":1,"endColumn":14,"fix":"227"},{"ruleId":"223","severity":1,"message":"224","line":1,"column":1,"nodeType":"225","messageId":"226","endLine":1,"endColumn":14,"fix":"228"},{"ruleId":"229","severity":1,"message":"230","line":3,"column":127,"nodeType":"203","messageId":"231","endLine":3,"endColumn":134},{"ruleId":"229","severity":1,"message":"230","line":3,"column":192,"nodeType":"203","messageId":"231","endLine":3,"endColumn":199},{"ruleId":"232","severity":1,"message":"233","line":28,"column":185,"nodeType":"234","messageId":"235","endLine":28,"endColumn":246},{"ruleId":"232","severity":1,"message":"233","line":28,"column":412,"nodeType":"234","messageId":"235","endLine":28,"endColumn":512},{"ruleId":"201","severity":1,"message":"236","line":42,"column":10,"nodeType":"203","messageId":"204","endLine":42,"endColumn":25},{"ruleId":"229","severity":1,"message":"237","line":50,"column":34,"nodeType":"203","messageId":"231","endLine":50,"endColumn":49},{"ruleId":"229","severity":1,"message":"238","line":60,"column":31,"nodeType":"203","messageId":"231","endLine":60,"endColumn":46},{"ruleId":"219","severity":1,"message":"239","line":176,"column":41,"nodeType":"221","messageId":"222","endLine":176,"endColumn":43},{"ruleId":"219","severity":1,"message":"239","line":176,"column":58,"nodeType":"221","messageId":"222","endLine":176,"endColumn":60},{"ruleId":"219","severity":1,"message":"220","line":564,"column":34,"nodeType":"221","messageId":"222","endLine":564,"endColumn":36},{"ruleId":"223","severity":1,"message":"224","line":1,"column":1,"nodeType":"225","messageId":"226","endLine":1,"endColumn":14,"fix":"240"},{"ruleId":"229","severity":1,"message":"230","line":3,"column":127,"nodeType":"203","messageId":"231","endLine":3,"endColumn":134},{"ruleId":"229","severity":1,"message":"230","line":3,"column":192,"nodeType":"203","messageId":"231","endLine":3,"endColumn":199},{"ruleId":"229","severity":1,"message":"241","line":24,"column":114,"nodeType":"203","messageId":"231","endLine":24,"endColumn":138},{"ruleId":"242","severity":1,"message":"243","line":26,"column":101,"nodeType":"244","messageId":"245","endLine":26,"endColumn":103},{"ruleId":"242","severity":1,"message":"243","line":26,"column":130,"nodeType":"244","messageId":"245","endLine":26,"endColumn":132},{"ruleId":"229","severity":1,"message":"246","line":28,"column":23,"nodeType":"203","messageId":"231","endLine":28,"endColumn":31},{"ruleId":"232","severity":1,"message":"233","line":36,"column":185,"nodeType":"234","messageId":"235","endLine":36,"endColumn":246},{"ruleId":"232","severity":1,"message":"233","line":36,"column":412,"nodeType":"234","messageId":"235","endLine":36,"endColumn":512},{"ruleId":"229","severity":1,"message":"237","line":46,"column":34,"nodeType":"203","messageId":"231","endLine":46,"endColumn":49},{"ruleId":"229","severity":1,"message":"238","line":56,"column":31,"nodeType":"203","messageId":"231","endLine":56,"endColumn":46},{"ruleId":"219","severity":1,"message":"239","line":180,"column":28,"nodeType":"221","messageId":"222","endLine":180,"endColumn":30},{"ruleId":"223","severity":1,"message":"224","line":1,"column":1,"nodeType":"225","messageId":"226","endLine":1,"endColumn":14,"fix":"247"},{"ruleId":"232","severity":1,"message":"233","line":41,"column":185,"nodeType":"234","messageId":"235","endLine":41,"endColumn":246},{"ruleId":"232","severity":1,"message":"233","line":41,"column":412,"nodeType":"234","messageId":"235","endLine":41,"endColumn":512},{"ruleId":"248","severity":1,"message":"249","line":310,"column":10,"nodeType":"250","messageId":"251","endLine":310,"endColumn":54},{"ruleId":"242","severity":1,"message":"243","line":650,"column":19,"nodeType":"244","messageId":"245","endLine":650,"endColumn":21},{"ruleId":"242","severity":1,"message":"243","line":650,"column":34,"nodeType":"244","messageId":"245","endLine":650,"endColumn":36},{"ruleId":"242","severity":1,"message":"243","line":673,"column":19,"nodeType":"244","messageId":"245","endLine":673,"endColumn":21},{"ruleId":"242","severity":1,"message":"243","line":673,"column":34,"nodeType":"244","messageId":"245","endLine":673,"endColumn":36},{"ruleId":"223","severity":1,"message":"224","line":1,"column":1,"nodeType":"225","messageId":"226","endLine":1,"endColumn":14,"fix":"252"},{"ruleId":"229","severity":1,"message":"230","line":3,"column":127,"nodeType":"203","messageId":"231","endLine":3,"endColumn":134},{"ruleId":"229","severity":1,"message":"230","line":3,"column":192,"nodeType":"203","messageId":"231","endLine":3,"endColumn":199},{"ruleId":"229","severity":1,"message":"241","line":18,"column":114,"nodeType":"203","messageId":"231","endLine":18,"endColumn":138},{"ruleId":"242","severity":1,"message":"243","line":20,"column":101,"nodeType":"244","messageId":"245","endLine":20,"endColumn":103},{"ruleId":"242","severity":1,"message":"243","line":20,"column":130,"nodeType":"244","messageId":"245","endLine":20,"endColumn":132},{"ruleId":"229","severity":1,"message":"246","line":22,"column":23,"nodeType":"203","messageId":"231","endLine":22,"endColumn":31},{"ruleId":"229","severity":1,"message":"237","line":36,"column":34,"nodeType":"203","messageId":"231","endLine":36,"endColumn":49},{"ruleId":"229","severity":1,"message":"238","line":46,"column":31,"nodeType":"203","messageId":"231","endLine":46,"endColumn":46},{"ruleId":"253","severity":1,"message":"254","line":144,"column":21,"nodeType":"255","messageId":"256","endLine":144,"endColumn":22},{"ruleId":"223","severity":1,"message":"224","line":1,"column":1,"nodeType":"225","messageId":"226","endLine":1,"endColumn":14,"fix":"257"},{"ruleId":"219","severity":1,"message":"220","line":101,"column":41,"nodeType":"221","messageId":"222","endLine":101,"endColumn":43},{"ruleId":"219","severity":1,"message":"220","line":139,"column":37,"nodeType":"221","messageId":"222","endLine":139,"endColumn":39},{"ruleId":"223","severity":1,"message":"224","line":1,"column":1,"nodeType":"225","messageId":"226","endLine":1,"endColumn":14,"fix":"258"},{"ruleId":"229","severity":1,"message":"230","line":3,"column":127,"nodeType":"203","messageId":"231","endLine":3,"endColumn":134},{"ruleId":"229","severity":1,"message":"230","line":3,"column":192,"nodeType":"203","messageId":"231","endLine":3,"endColumn":199},{"ruleId":"232","severity":1,"message":"233","line":32,"column":185,"nodeType":"234","messageId":"235","endLine":32,"endColumn":246},{"ruleId":"232","severity":1,"message":"233","line":32,"column":412,"nodeType":"234","messageId":"235","endLine":32,"endColumn":512},{"ruleId":"229","severity":1,"message":"237","line":42,"column":34,"nodeType":"203","messageId":"231","endLine":42,"endColumn":49},{"ruleId":"229","severity":1,"message":"238","line":52,"column":31,"nodeType":"203","messageId":"231","endLine":52,"endColumn":46},{"ruleId":"242","severity":1,"message":"259","line":310,"column":33,"nodeType":"244","messageId":"245","endLine":310,"endColumn":35},{"ruleId":"242","severity":1,"message":"259","line":310,"column":88,"nodeType":"244","messageId":"245","endLine":310,"endColumn":90},{"ruleId":"219","severity":1,"message":"220","line":536,"column":37,"nodeType":"221","messageId":"222","endLine":536,"endColumn":39},{"ruleId":"223","severity":1,"message":"224","line":1,"column":1,"nodeType":"225","messageId":"226","endLine":1,"endColumn":14,"fix":"260"},{"ruleId":"261","severity":1,"message":"262","line":95,"column":89,"nodeType":"221","messageId":"263","endLine":95,"endColumn":90},{"ruleId":"219","severity":1,"message":"220","line":480,"column":32,"nodeType":"221","messageId":"222","endLine":480,"endColumn":34},{"ruleId":"219","severity":1,"message":"239","line":674,"column":41,"nodeType":"221","messageId":"222","endLine":674,"endColumn":43},{"ruleId":"219","severity":1,"message":"239","line":674,"column":58,"nodeType":"221","messageId":"222","endLine":674,"endColumn":60},{"ruleId":"264","severity":1,"message":"265","line":143,"column":3,"nodeType":"266","messageId":"267","endLine":146,"endColumn":4},{"ruleId":"219","severity":1,"message":"239","line":213,"column":24,"nodeType":"221","messageId":"222","endLine":213,"endColumn":26},{"ruleId":"268","severity":1,"message":"269","line":38,"column":3,"nodeType":"270","messageId":"222","endLine":38,"endColumn":7},{"ruleId":"271","severity":1,"message":"272","line":75,"column":1,"nodeType":"273","endLine":211,"endColumn":3},{"ruleId":"219","severity":1,"message":"220","line":80,"column":39,"nodeType":"221","messageId":"222","endLine":80,"endColumn":41},{"ruleId":"219","severity":1,"message":"220","line":111,"column":37,"nodeType":"221","messageId":"222","endLine":111,"endColumn":39},{"ruleId":"219","severity":1,"message":"220","line":615,"column":35,"nodeType":"221","messageId":"222","endLine":615,"endColumn":37},"no-unused-vars","'Route' is defined but never used.","Identifier","unusedVar","'Switch' is defined but never used.","'useLocation' is defined but never used.","'useHistory' is defined but never used.","'width' is assigned a value but never used.","'dispatch' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'onMessage'. Either include it or remove the dependency array.","ArrayExpression",["274"],"no-native-reassign",["275"],"no-negated-in-lhs",["276"],"'length' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","strict","'use strict' is unnecessary inside of modules.","ExpressionStatement","module",{"range":"277","text":"278"},{"range":"279","text":"278"},"no-func-assign","'_typeof' is a function.","isAFunction","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'source'.","FunctionExpression","unsafeRefs","'_classCallCheck' is defined but never used.","'_setPrototypeOf' is a function.","'_getPrototypeOf' is a function.","Expected '!==' and instead saw '!='.",{"range":"280","text":"278"},"'_getRequireWildcardCache' is a function.","no-mixed-operators","Unexpected mix of '||' and '&&'.","LogicalExpression","unexpectedMixedOperator","'_extends' is a function.",{"range":"281","text":"278"},"no-cond-assign","Expected a conditional expression and instead saw an assignment.","AssignmentExpression","missing",{"range":"282","text":"278"},"no-sequences","Unexpected use of comma operator.","SequenceExpression","unexpectedCommaExpression",{"range":"283","text":"278"},{"range":"284","text":"278"},"Unexpected mix of '&&' and '||'.",{"range":"285","text":"278"},"no-useless-concat","Unexpected string concatenation of literals.","unexpectedConcat","no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","no-eval","eval can be harmful.","CallExpression","import/no-anonymous-default-export","Assign object to a variable before exporting as module default","ExportDefaultDeclaration",{"desc":"286","fix":"287"},"no-global-assign","no-unsafe-negation",[0,13],"",[0,13],[0,13],[0,13],[0,13],[0,13],[0,13],[0,13],"Update the dependencies array to be: [onMessage]",{"range":"288","text":"289"},[1259,1261],"[onMessage]"]